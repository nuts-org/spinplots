var __index = {"config":{"lang":["en"],"separator":"[\\s\\-,:!=\\[\\]()\"`/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"SpinPlots","text":"<p>Welcome to the documentation for <code>SpinPlots</code>! This Python package is designed to simplify the process of reading and plotting NMR data. While NMRglue is a powerful library for reading, processing, and analyzing NMR data, creating basic plots often requires a lot of code. <code>SpinPlots</code> streamlines these tasks, allowing you to produce clean, publication-ready plots with minimal effort.</p> <p>For example, to generate a simple 1D NMR plot using NMRglue, you would typically write the following:</p> <pre><code># Import python libraries\nimport nmrglue as ng\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# Read Bruker's processed data\ndic, data = ng.bruker.read_pdata(\"Data/1/pdata/1/\")\n\n# Get universal dic\nudic = ng.bruker.guess_udic(dic, data)\n\n# Create a unit conversion object for the axis\nuc = ng.fileiobase.uc_from_udic(udic)\n\n# Get ppm scale\nppm_scale = uc.ppm_scale()\n\n# Plot the spectrum\nplt.plot(ppm_scale, data, label=\"Sample X\")\nplt.xlim(20, 0)\nplt.xlabel(\"$^1$H (ppm)\")\nplt.ylabel(\"Intensity (a.u.)\")\nplt.legend()\n\n# Save the figure\nfig.savefig(\"spectrum.png\")\n</code></pre> <p>This is a lot of code for a simple 1D plot! If one wants to make a 2D plot with projections things become even harder</p> <p><code>SpinPlots</code> tries to simplify the process. With just one function call, you can create the same 1D plot:</p> <pre><code>from spinplots.io import read_nmr\n\ndata = read_nmr(\"data/1/pdata/1/\")\ndata.plot(\n    labels=[\"Sample X\"],\n    xlim=(20, 0),\n    save=True,\n    filename=\"spectrum\",\n    format=\"png\"\n)\n</code></pre>"},{"location":"about/changelog.html","title":"Changelog","text":"<p>All notable changes to this project will be documented in this file.</p> <p>The format is based on Keep a Changelog, and this project adheres to Semantic Versioning.</p>"},{"location":"about/changelog.html#010","title":"[0.1.0]","text":""},{"location":"about/changelog.html#added","title":"Added","text":"<ul> <li>Terminal functionality: Added <code>bruker2csv</code> to convert NMR data into CSV from the terminal.</li> <li>Plotting functions: Added the following functions to streamline plotting:<ul> <li><code>bruker1d</code> for generating 1D NMR plots</li> <li><code>bruker1d_grid</code> for generating subplots</li> <li><code>bruker2d</code> for generating 2D NMR plots</li> </ul> </li> <li>NMR dataframe: Added the <code>nmr_df</code> function to create a Pandas DataFrame from NMR data, for further data manipulation, analysis and plotting.</li> <li>Tutorials:<ul> <li>Creating 1D and 2D plots using the spinplots functions.</li> <li>Obtain a Pandas DataFrame from NMR data for custom plot styling and manipulation.</li> </ul> </li> </ul>"},{"location":"about/changelog.html#001","title":"[0.0.1]","text":""},{"location":"about/changelog.html#added_1","title":"Added","text":"<ul> <li>The initial release!</li> </ul>"},{"location":"about/contributors.html","title":"People","text":"<p>SpinPlots was originally written and is actively maintained by Carlos Bornes, Daniel Pereira and M\u00e1rcio Soares</p>"},{"location":"about/contributors.html#contributorscontributions","title":"Contributors/Contributions","text":"<p>Additional contributions were made by the individuals listed here.</p>"},{"location":"about/contributors.html#inspiration","title":"Inspiration","text":"<p>Some project that served as inspiration for SpinPlots are:</p> <ul> <li> <p>Quantum Accelerators Python package template created by Andrew S. Rosen</p> </li> <li> <p>NMRglue by Jonathan J. Helmus for providing Python function for reading, processing NMR data</p> </li> <li> <p>Our own frustration trying to remember NMRglue's syntax and using Bruker's TopSpin for producing plots for papers. \ud83e\udd2a</p> </li> </ul>"},{"location":"about/license.html","title":"License","text":"LICENSE.md<pre><code>MIT License\n\nCopyright (c) 2024\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n</code></pre>"},{"location":"installation/install.html","title":"Installation","text":"<p>If you have Python and pip installed, you can easily install Spinplots with the following command:</p> <pre><code>pip install git+https://github.com/nuts-org/spinplots@v0.2-dev\n</code></pre> <p>All dependecies <code>pyproject.toml</code> file are installed automatically.</p> <p>To verify that the package has been installed successfully, open a Python console and run:</p> <pre><code>import spinplots\n</code></pre>"},{"location":"reference/SUMMARY.html","title":"SUMMARY","text":"<ul> <li>spinplots<ul> <li>cli</li> <li>io</li> <li>plot</li> <li>spin</li> <li>utils</li> </ul> </li> </ul>"},{"location":"reference/spinplots/cli.html","title":"cli","text":""},{"location":"reference/spinplots/cli.html#spinplots.cli.main","title":"main","text":"<pre><code>main()\n</code></pre> <p>Convert Bruker's NMR data to csv files on the terminal</p> Source code in <code>spinplots/cli.py</code> <pre><code>def main():\n    \"\"\"\n    Convert Bruker's NMR data to csv files on the terminal\n    \"\"\"\n    if len(sys.argv) != 3:\n        logging.error(\"Incorrect number of arguments provided.\")\n        logging.error(\"Usage: bruker2csv &lt;path_to_data&gt; &lt;path_to_output&gt;\")\n\n        sys.exit(1)\n\n    data_path = sys.argv[1]\n    output_path = sys.argv[2]\n\n    try:\n        df_nmr = nmr_df(data_path)\n        if df_nmr.attrs.get(\"nmr_dim\") == 2:\n            df_nmr.to_csv(output_path, index=True)\n            logging.info(f\"Data written to {output_path}\")\n        elif df_nmr.attrs.get(\"nmr_dim\") == 1:\n            df_nmr.to_csv(output_path, index=False)\n            logging.info(f\"Data written to {output_path}\")\n    except Exception as e:\n        logging.error(f\"An error occurred: {e}\")\n        sys.exit(1)\n</code></pre>"},{"location":"reference/spinplots/io.html","title":"io","text":""},{"location":"reference/spinplots/io.html#spinplots.io.read_nmr","title":"read_nmr","text":"<pre><code>read_nmr(path, provider='bruker', tags=None, **kwargs)\n</code></pre> <p>Reads NMR data from a specified path or list of paths and provider, returning a single Spin object containing all datasets.</p> <p>Args:     path (str | list[str]): Path or list of paths to the NMR data directory(ies).     provider (str): The NMR data provider (currently only 'bruker' is supported).     **kwargs: Additional provider-specific arguments passed to the reader               (e.g., 'homo' for Bruker 2D).</p> <p>Returns:     Spin: A Spin object containing the data for all successfully read spectra.</p> <p>Raises:     ValueError: If the provider is not supported.     IOError: If there are problems processing the files.</p> Source code in <code>spinplots/io.py</code> <pre><code>def read_nmr(\n    path: str | list[str],\n    provider: str = \"bruker\",\n    tags: str | list[str] | None = None,\n    **kwargs,\n) -&gt; Spin | SpinCollection:\n    \"\"\"\n    Reads NMR data from a specified path or list of paths and provider,\n    returning a single Spin object containing all datasets.\n\n    Args:\n        path (str | list[str]): Path or list of paths to the NMR data directory(ies).\n        provider (str): The NMR data provider (currently only 'bruker' is supported).\n        **kwargs: Additional provider-specific arguments passed to the reader\n                  (e.g., 'homo' for Bruker 2D).\n\n    Returns:\n        Spin: A Spin object containing the data for all successfully read spectra.\n\n    Raises:\n        ValueError: If the provider is not supported.\n        IOError: If there are problems processing the files.\n    \"\"\"\n\n    provider = provider.lower()\n\n    paths_to_read = path if isinstance(path, list) else [path]\n\n    if tags is not None and len(tags) != len(paths_to_read):\n        raise ValueError(\"Length of tags must match the number of paths.\")\n\n    spins = []\n\n    for i, p in enumerate(paths_to_read):\n        match provider:\n            case \"bruker\":\n                spectrum_data = _read_bruker_data(p, **kwargs)\n            case \"dmfit\":\n                spectrum_data = _read_dmfit_data(p, **kwargs)\n            case _:\n                raise ValueError(\n                    f\"Unsupported provider: {provider}. Only 'bruker' and 'dmfit' are supported.\"\n                )\n\n        tag = tags[i] if tags is not None else None\n        spin = Spin(spectrum_data=spectrum_data, provider=provider, tag=tag)\n        spins.append(spin)\n\n    if len(spins) == 1:\n        return spins[0]\n\n    return SpinCollection(spins)\n</code></pre>"},{"location":"reference/spinplots/plot.html","title":"plot","text":""},{"location":"reference/spinplots/plot.html#spinplots.plot.bruker1d","title":"bruker1d","text":"<pre><code>bruker1d(spectra, labels=None, xlim=None, save=False, filename=None, format=None, frame=False, normalize=None, stacked=False, color=None, return_fig=False, **kwargs)\n</code></pre> <p>Plots one or more 1D NMR spectra from spectrum dictionaries.</p> <p>Parameters:     spectra (dict or list): Dictionary or list of dictionaries containing spectrum data.     labels (list, optional): List of labels for the spectra.     xlim (tuple, optional): The limits for the x-axis.     save (bool, optional): Whether to save the plot.     filename (str, optional): The name of the file to save the plot.     format (str, optional): The format to save the file in.     frame (bool, optional): Whether to show the frame.     normalize (str, optional): Normalization method ('max', 'scans', or None).     stacked (bool, optional): Whether to stack the spectra.     color (list, optional): List of colors for the spectra.     return_fig (bool, optional): Whether to return the figure and axes.     **kwargs: Additional keyword arguments for customizing the plot.</p> <p>Returns:     None or tuple: If return_fig is True, returns the figure and axes.</p> Source code in <code>spinplots/plot.py</code> <pre><code>def bruker1d(\n    spectra: dict | list[dict],\n    labels: list[str] | None = None,\n    xlim: tuple[float, float] | None = None,\n    save: bool = False,\n    filename: str | None = None,\n    format: str | None = None,\n    frame: bool = False,\n    normalize: str | None = None,\n    stacked: bool = False,\n    color: list[str] | None = None,\n    return_fig: bool = False,\n    **kwargs,\n):\n    \"\"\"\n    Plots one or more 1D NMR spectra from spectrum dictionaries.\n\n    Parameters:\n        spectra (dict or list): Dictionary or list of dictionaries containing spectrum data.\n        labels (list, optional): List of labels for the spectra.\n        xlim (tuple, optional): The limits for the x-axis.\n        save (bool, optional): Whether to save the plot.\n        filename (str, optional): The name of the file to save the plot.\n        format (str, optional): The format to save the file in.\n        frame (bool, optional): Whether to show the frame.\n        normalize (str, optional): Normalization method ('max', 'scans', or None).\n        stacked (bool, optional): Whether to stack the spectra.\n        color (list, optional): List of colors for the spectra.\n        return_fig (bool, optional): Whether to return the figure and axes.\n        **kwargs: Additional keyword arguments for customizing the plot.\n\n    Returns:\n        None or tuple: If return_fig is True, returns the figure and axes.\n    \"\"\"\n\n    spectra = spectra if isinstance(spectra, list) else [spectra]\n\n    if not all(s[\"ndim\"] == 1 for s in spectra):\n        raise ValueError(\"All spectra must be 1-dimensional for bruker1d.\")\n\n    defaults = DEFAULTS.copy()\n    defaults[\"yaxislabel\"] = None\n    defaults.update(\n        {k: v for k, v in kwargs.items() if k in defaults and v is not None}\n    )\n\n    fig, ax = plt.subplots()\n\n    current_stack_offset = 0.0\n\n    first_nuclei = spectra[0][\"nuclei\"]\n    number, nucleus = (\n        \"\".join(filter(str.isdigit, first_nuclei)),\n        \"\".join(filter(str.isalpha, first_nuclei)),\n    )\n\n    for i, spectrum in enumerate(spectra):\n        data_to_plot = None\n        if normalize == \"max\":\n            data_to_plot = spectrum.get(\"norm_max\")\n            if data_to_plot is None:\n                warnings.warn(\n                    f\"Pre-calculated 'norm_max' data not found for {spectrum['path']}. Plotting raw data.\",\n                    UserWarning,\n                )\n                data_to_plot = spectrum[\"data\"]\n        elif normalize == \"scans\":\n            data_to_plot = spectrum.get(\"norm_scans\")\n            if data_to_plot is None:\n                warnings.warn(\n                    f\"Pre-calculated 'norm_scans' data not found or calculation failed for {spectrum['path']}. Plotting raw data.\",\n                    UserWarning,\n                )\n                data_to_plot = spectrum[\"data\"]\n        elif normalize is None or normalize is False:\n            data_to_plot = spectrum[\"data\"]\n        else:\n            raise ValueError(\n                f\"Invalid normalize option: '{normalize}'. Choose 'max', 'scans', or None.\"\n            )\n\n        ppm = spectrum[\"ppm_scale\"]\n\n        plot_data_adjusted = data_to_plot\n        if stacked:\n            # Apply the offset\n            plot_data_adjusted = data_to_plot + current_stack_offset\n            current_stack_offset += np.amax(data_to_plot) * 1.1\n\n        plot_kwargs = {\n            \"linestyle\": defaults[\"linestyle\"],\n            \"linewidth\": defaults[\"linewidth\"],\n            \"alpha\": defaults[\"alpha\"],\n        }\n\n        if labels:\n            plot_kwargs[\"label\"] = labels[i] if i &lt; len(labels) else f\"Spectrum {i + 1}\"\n\n        if color:\n            plot_kwargs[\"color\"] = color[i] if i &lt; len(color) else None\n\n        ax.plot(ppm, plot_data_adjusted, **plot_kwargs)\n\n    if labels:\n        ax.legend(\n            bbox_to_anchor=(1.05, 1),\n            loc=\"upper left\",\n            fontsize=defaults[\"labelsize\"],\n            prop={\"family\": defaults[\"tickfont\"], \"size\": defaults[\"labelsize\"]},\n        )\n\n    # --- Axis Setup ---\n    if xaxislabel := defaults[\"xaxislabel\"]:\n        ax.set_xlabel(\n            xaxislabel, fontsize=defaults[\"axisfontsize\"], fontname=defaults[\"axisfont\"]\n        )\n    else:\n        # Use nucleus info from the first spectrum\n        ax.set_xlabel(\n            f\"$^{{{number}}}\\\\mathrm{{{nucleus}}}$ (ppm)\",\n            fontsize=defaults[\"axisfontsize\"],\n            fontname=defaults[\"axisfont\"],\n        )\n\n    ax.tick_params(\n        axis=\"x\",\n        labelsize=defaults[\"tickfontsize\"],\n        labelfontfamily=defaults[\"tickfont\"],\n    )\n\n    if defaults[\"tickspacing\"]:\n        ax.xaxis.set_major_locator(plt.MultipleLocator(defaults[\"tickspacing\"]))\n\n    if not frame:\n        ax.spines[\"top\"].set_visible(False)\n        ax.spines[\"right\"].set_visible(False)\n        ax.spines[\"left\"].set_visible(False)\n        ax.set_yticklabels([])\n        ax.set_yticks([])\n    else:\n        ax.set_ylabel(\n            defaults[\"yaxislabel\"],\n            fontsize=defaults[\"axisfontsize\"],\n            fontname=defaults[\"axisfont\"],\n        )\n        ax.tick_params(\n            axis=\"y\",\n            labelsize=defaults[\"tickfontsize\"],\n            labelfontfamily=defaults[\"tickfont\"],\n        )\n\n    if xlim:\n        ax.set_xlim(xlim)\n    else:\n        current_xlim = ax.get_xlim()\n        if current_xlim[0] &lt; current_xlim[1]:\n            ax.set_xlim(current_xlim[::-1])\n\n    if save:\n        if not filename or not format:\n            raise ValueError(\"Both filename and format must be provided if save=True.\")\n        full_filename = f\"{filename}.{format}\"\n        fig.savefig(\n            full_filename, format=format, dpi=300, bbox_inches=\"tight\", pad_inches=0.1\n        )\n        plt.show()\n        return None\n\n    if return_fig:\n        return fig, ax\n\n    plt.show()\n    return None\n</code></pre>"},{"location":"reference/spinplots/plot.html#spinplots.plot.bruker1d_grid","title":"bruker1d_grid","text":"<pre><code>bruker1d_grid(spectra, labels=None, subplot_dims=(1, 1), xlim=None, save=False, filename=None, format='png', frame=False, normalize=False, color=None, return_fig=False, **kwargs)\n</code></pre> <p>Plots 1D NMR spectra from Bruker data in subplots.</p> <p>Parameters:     spectra (dict or list): Dictionary or list of dictionaries containing spectrum data.     labels (list): List of labels for the spectra.     subplot_dims (tuple): Dimensions of the subplot grid (rows, cols).     xlim (list of tuples or tuple): The limits for the x-axis.     save (bool): Whether to save the plot.     filename (str): The name of the file to save the plot.     format (str): The format to save the file in.     frame (bool): Whether to show the frame.     normalize (str): Normalization method 'max', 'scans', or None.     color (str): List of colors for the spectra.     return_fig (bool): Whether to return the figure and axis.     **kwargs: Additional keyword arguments for customizing the plot.</p> <p>Returns:     None or tuple: If return_fig is True, returns the figure and axis.</p> <p>Example:     bruker1d_grid([spectrum1, spectrum2], labels=['Spectrum 1', 'Spectrum 2'], subplot_dims=(1, 2), xlim=[(0, 100), (0, 100)], save=True, filename='1d_spectra', format='png', frame=False, normalize='max', color=['red', 'blue'])</p> Source code in <code>spinplots/plot.py</code> <pre><code>def bruker1d_grid(\n    spectra: dict | list[dict],\n    labels=None,\n    subplot_dims=(1, 1),\n    xlim=None,\n    save=False,\n    filename=None,\n    format=\"png\",\n    frame=False,\n    normalize=False,\n    color=None,\n    return_fig=False,\n    **kwargs,\n):\n    \"\"\"\n    Plots 1D NMR spectra from Bruker data in subplots.\n\n    Parameters:\n        spectra (dict or list): Dictionary or list of dictionaries containing spectrum data.\n        labels (list): List of labels for the spectra.\n        subplot_dims (tuple): Dimensions of the subplot grid (rows, cols).\n        xlim (list of tuples or tuple): The limits for the x-axis.\n        save (bool): Whether to save the plot.\n        filename (str): The name of the file to save the plot.\n        format (str): The format to save the file in.\n        frame (bool): Whether to show the frame.\n        normalize (str): Normalization method 'max', 'scans', or None.\n        color (str): List of colors for the spectra.\n        return_fig (bool): Whether to return the figure and axis.\n        **kwargs: Additional keyword arguments for customizing the plot.\n\n    Returns:\n        None or tuple: If return_fig is True, returns the figure and axis.\n\n    Example:\n        bruker1d_grid([spectrum1, spectrum2], labels=['Spectrum 1', 'Spectrum 2'], subplot_dims=(1, 2), xlim=[(0, 100), (0, 100)], save=True, filename='1d_spectra', format='png', frame=False, normalize='max', color=['red', 'blue'])\n    \"\"\"\n\n    spectra = spectra if isinstance(spectra, list) else [spectra]\n\n    if not all(s[\"ndim\"] == 1 for s in spectra):\n        raise ValueError(\"All spectra must be 1-dimensional for bruker1d_grid.\")\n\n    defaults = DEFAULTS.copy()\n    defaults.update(\n        {k: v for k, v in kwargs.items() if k in defaults and v is not None}\n    )\n\n    rows, cols = subplot_dims\n    fig, axes = plt.subplots(rows, cols, figsize=(5 * cols, 4 * rows))\n    axes = axes.flatten() if rows * cols &gt; 1 else [axes]\n\n    for i, spectrum in enumerate(spectra):\n        if i &gt;= len(axes):\n            break\n\n        ax = axes[i]\n\n        nuclei = spectrum[\"nuclei\"]\n        number, nucleus = (\n            \"\".join(filter(str.isdigit, nuclei)),\n            \"\".join(filter(str.isalpha, nuclei)),\n        )\n\n        ppm = spectrum[\"ppm_scale\"]\n        if isinstance(normalize, list):\n            if len(normalize) != len(spectra):\n                raise ValueError(\n                    \"The length of the normalize list must be equal to the number of spectra.\"\n                )\n            normalize_option = normalize[i]\n        else:\n            normalize_option = normalize\n\n        if normalize_option == \"max\" or normalize_option is True:\n            data = spectrum.get(\"norm_max\")\n            if data is None:\n                data = spectrum[\"data\"] / np.amax(spectrum[\"data\"])\n        elif normalize_option == \"scans\":\n            data = spectrum.get(\"norm_scans\")\n            if data is None:\n                warnings.warn(\n                    f\"Pre-calculated 'norm_scans' data not found for {spectrum['path']}. Using raw data.\",\n                    UserWarning,\n                )\n                data = spectrum[\"data\"]\n        else:\n            data = spectrum[\"data\"]\n\n        plot_kwargs = {\n            \"linestyle\": defaults[\"linestyle\"],\n            \"linewidth\": defaults[\"linewidth\"],\n            \"alpha\": defaults[\"alpha\"],\n        }\n\n        if labels and i &lt; len(labels):\n            plot_kwargs[\"label\"] = labels[i]\n\n        if color and i &lt; len(color):\n            plot_kwargs[\"color\"] = color[i]\n\n        ax.plot(ppm, data, **plot_kwargs)\n\n        if labels and i &lt; len(labels):\n            ax.legend(\n                fontsize=defaults[\"labelsize\"],\n                prop={\"family\": defaults[\"tickfont\"], \"size\": defaults[\"labelsize\"]},\n            )\n\n        if xaxislabel := defaults[\"xaxislabel\"]:\n            ax.set_xlabel(\n                xaxislabel,\n                fontsize=defaults[\"axisfontsize\"],\n                fontname=defaults[\"axisfont\"],\n            )\n        else:\n            ax.set_xlabel(\n                f\"$^{{{number}}}\\\\mathrm{{{nucleus}}}$ (ppm)\",\n                fontsize=defaults[\"axisfontsize\"],\n                fontname=defaults[\"axisfont\"],\n            )\n\n        ax.tick_params(\n            axis=\"x\",\n            labelsize=defaults[\"tickfontsize\"],\n            labelfontfamily=defaults[\"tickfont\"],\n        )\n\n        if defaults[\"tickspacing\"]:\n            from matplotlib.ticker import MultipleLocator\n\n            ax.xaxis.set_major_locator(MultipleLocator(defaults[\"tickspacing\"]))\n\n        if not frame:\n            ax.spines[\"top\"].set_visible(False)\n            ax.spines[\"right\"].set_visible(False)\n            ax.spines[\"left\"].set_visible(False)\n            ax.set_yticklabels([])\n            ax.set_yticks([])\n        else:\n            if yaxislabel := defaults[\"yaxislabel\"]:\n                ax.set_ylabel(\n                    yaxislabel,\n                    fontsize=defaults[\"axisfontsize\"],\n                    fontname=defaults[\"axisfont\"],\n                )\n            else:\n                ax.set_ylabel(\n                    defaults[\"yaxislabel\"],\n                    fontsize=defaults[\"axisfontsize\"],\n                    fontname=defaults[\"axisfont\"],\n                )\n\n                ax.tick_params(\n                    axis=\"y\",\n                    labelsize=defaults[\"tickfontsize\"],\n                    labelfontfamily=defaults[\"tickfont\"],\n                )\n\n        if xlim and isinstance(xlim, tuple):\n            ax.set_xlim(xlim)\n        elif xlim and isinstance(xlim, list) and i &lt; len(xlim):\n            ax.set_xlim(xlim[i])\n\n    plt.tight_layout()\n\n    if save:\n        if filename:\n            full_filename = f\"{filename}.{format}\"\n        else:\n            full_filename = f\"1d_nmr_spectra.{format}\"\n        fig.savefig(\n            full_filename, format=format, dpi=300, bbox_inches=\"tight\", pad_inches=0.1\n        )\n        return None\n    elif return_fig:\n        return fig, axes\n\n    plt.show()\n    return None\n</code></pre>"},{"location":"reference/spinplots/plot.html#spinplots.plot.bruker2d","title":"bruker2d","text":"<pre><code>bruker2d(spectra, contour_start=100000.0, contour_num=10, contour_factor=1.2, cmap=None, colors=None, proj_colors=None, xlim=None, ylim=None, save=False, filename=None, format=None, diag=None, homo=False, return_fig=False, **kwargs)\n</code></pre> <p>Plots a 2D NMR spectrum from spectrum dictionaries.</p> <p>Parameters:     spectra (dict or list): Dictionary or list of dictionaries containing spectrum data.     contour_start (float, optional): Start value for the contour levels. Default is 1e5.     contour_num (int, optional): Number of contour levels. Default is 10.     contour_factor (float, optional): Factor by which the contour levels increase. Default is 1.2.</p> <p>Keyword arguments:     cmap (str or list): Colormap(s) to use for the contour lines.     colors (list): Colors to use when overlaying spectra.     proj_colors (list): Colors to use for the projections.     xlim (tuple): The limits for the x-axis.     ylim (tuple): The limits for the y-axis.     save (bool): Whether to save the plot.     filename (str): The name of the file to save the plot.     format (str): The format to save the file in.     diag (float or None): Slope of the diagonal line/None.     homo (bool): True if doing homonuclear experiment. When True, both axes will show the same nucleus.     return_fig (bool): Whether to return the figure and axes.     **kwargs: Additional keyword arguments for customizing the plot.</p> <p>Example:     bruker2d(spectrum, 0.1, 10, 1.2, cmap='viridis', xlim=(0, 100), ylim=(0, 100), save=True, filename='2d_spectrum', format='png', diag=True)</p> Source code in <code>spinplots/plot.py</code> <pre><code>def bruker2d(\n    spectra: dict | list[dict],\n    contour_start: float = 1e5,\n    contour_num: int = 10,\n    contour_factor: float = 1.2,\n    cmap: str | list[str] | None = None,\n    colors: list[str] | None = None,\n    proj_colors=None,\n    xlim=None,\n    ylim=None,\n    save=False,\n    filename=None,\n    format=None,\n    diag=None,\n    homo=False,\n    return_fig=False,\n    **kwargs,\n):\n    \"\"\"\n    Plots a 2D NMR spectrum from spectrum dictionaries.\n\n    Parameters:\n        spectra (dict or list): Dictionary or list of dictionaries containing spectrum data.\n        contour_start (float, optional): Start value for the contour levels. Default is 1e5.\n        contour_num (int, optional): Number of contour levels. Default is 10.\n        contour_factor (float, optional): Factor by which the contour levels increase. Default is 1.2.\n\n    Keyword arguments:\n        cmap (str or list): Colormap(s) to use for the contour lines.\n        colors (list): Colors to use when overlaying spectra.\n        proj_colors (list): Colors to use for the projections.\n        xlim (tuple): The limits for the x-axis.\n        ylim (tuple): The limits for the y-axis.\n        save (bool): Whether to save the plot.\n        filename (str): The name of the file to save the plot.\n        format (str): The format to save the file in.\n        diag (float or None): Slope of the diagonal line/None.\n        homo (bool): True if doing homonuclear experiment. When True, both axes will show the same nucleus.\n        return_fig (bool): Whether to return the figure and axes.\n        **kwargs: Additional keyword arguments for customizing the plot.\n\n    Example:\n        bruker2d(spectrum, 0.1, 10, 1.2, cmap='viridis', xlim=(0, 100), ylim=(0, 100), save=True, filename='2d_spectrum', format='png', diag=True)\n    \"\"\"\n\n    spectra = spectra if isinstance(spectra, list) else [spectra]\n\n    if not all(s[\"ndim\"] == 2 for s in spectra):\n        raise ValueError(\"All spectra must be 2-dimensional for bruker2d.\")\n\n    defaults = DEFAULTS.copy()\n    defaults[\"yaxislabel\"] = None\n    defaults.update(\n        {k: v for k, v in kwargs.items() if k in defaults and v is not None}\n    )\n\n    fig = plt.figure(constrained_layout=False)\n    ax = fig.subplot_mosaic(\n        \"\"\"\n    .a\n    bA\n    \"\"\",\n        gridspec_kw={\n            \"height_ratios\": [0.9, 6.0],\n            \"width_ratios\": [0.8, 6.0],\n            \"wspace\": 0.03,\n            \"hspace\": 0.04,\n        },\n    )\n\n    for i, spectrum in enumerate(spectra):\n        data = spectrum[\"data\"]\n\n        nuclei_list = spectrum[\"nuclei\"]\n\n        if homo:\n            nuclei_x = nuclei_list[1]\n            nuclei_y = nuclei_list[1]\n        else:\n            nuclei_x = nuclei_list[1]\n            nuclei_y = nuclei_list[0]\n\n        number_x, nucleus_x = (\n            \"\".join(filter(str.isdigit, nuclei_x)),\n            \"\".join(filter(str.isalpha, nuclei_x)),\n        )\n        number_y, nucleus_y = (\n            \"\".join(filter(str.isdigit, nuclei_y)),\n            \"\".join(filter(str.isalpha, nuclei_y)),\n        )\n        ppm_x = spectrum[\"ppm_scale\"][1]\n        ppm_x_limits = (ppm_x[0], ppm_x[-1])\n        ppm_y = spectrum[\"ppm_scale\"][0]\n\n        if xlim:\n            x_min_idx = np.abs(ppm_x - max(xlim)).argmin()\n            x_max_idx = np.abs(ppm_x - min(xlim)).argmin()\n            x_indices = slice(min(x_min_idx, x_max_idx), max(x_min_idx, x_max_idx))\n        else:\n            x_indices = slice(None)\n\n        if ylim:\n            y_min_idx = np.abs(ppm_y - max(ylim)).argmin()\n            y_max_idx = np.abs(ppm_y - min(ylim)).argmin()\n            y_indices = slice(min(y_min_idx, y_max_idx), max(y_min_idx, y_max_idx))\n        else:\n            y_indices = slice(None)\n\n        if (\n            isinstance(spectrum[\"projections\"], dict)\n            and \"x\" in spectrum[\"projections\"]\n            and \"y\" in spectrum[\"projections\"]\n        ):\n            if xlim is None and ylim is None:\n                proj_x = spectrum[\"projections\"][\"x\"]\n                proj_y = spectrum[\"projections\"][\"y\"]\n            else:\n                zoomed_data = data[y_indices, x_indices]\n                proj_x = np.amax(zoomed_data, axis=0)\n                proj_y = np.amax(zoomed_data, axis=1)\n        else:\n            zoomed_data = data[y_indices, x_indices]\n            proj_x = np.amax(zoomed_data, axis=0)\n            proj_y = np.amax(zoomed_data, axis=1)\n\n        contour_levels = contour_start * contour_factor ** np.arange(contour_num)\n\n        x_proj_ppm = ppm_x[x_indices]\n        y_proj_ppm = ppm_y[y_indices]\n\n        if cmap is not None:\n            from matplotlib.colors import LogNorm\n\n            if isinstance(cmap, str):\n                cmap = [cmap]\n\n            if len(cmap) &gt; 1:\n                warnings.warn(\n                    \"Warning: Consider using colors instead of cmap\"\n                    \"when overlapping spectra.\"\n                )\n\n            cmap_i = plt.get_cmap(cmap[i % len(cmap)])\n            ax[\"A\"].contour(\n                x_proj_ppm,\n                y_proj_ppm,\n                data[y_indices, x_indices],\n                contour_levels,\n                cmap=cmap_i,\n                linewidths=defaults[\"linewidth_contour\"],\n                norm=LogNorm(vmin=contour_levels[0], vmax=contour_levels[-1]),\n            )\n\n            if proj_colors and i &lt; len(proj_colors):\n                proj_color = proj_colors[i]\n            else:\n                proj_color = cmap_i(\n                    mcolors.Normalize(\n                        vmin=contour_levels.min(), vmax=contour_levels.max()\n                    )(contour_levels[0])\n                )\n\n            ax[\"a\"].plot(\n                x_proj_ppm,\n                proj_x,\n                linewidth=defaults[\"linewidth_proj\"],\n                color=proj_color,\n            )\n            ax[\"a\"].axis(False)\n            ax[\"b\"].plot(\n                -proj_y,\n                y_proj_ppm,\n                linewidth=defaults[\"linewidth_proj\"],\n                color=proj_color,\n            )\n            ax[\"b\"].axis(False)\n        elif cmap is not None and colors is not None:\n            raise ValueError(\"Only one of cmap or colors can be provided.\")\n        elif colors is not None and cmap is None:\n            contour_color = colors[i % len(colors)]\n            ax[\"A\"].contour(\n                x_proj_ppm,\n                y_proj_ppm,\n                data[y_indices, x_indices],\n                contour_levels,\n                colors=contour_color,\n                linewidths=defaults[\"linewidth_contour\"],\n            )\n\n            if proj_colors and i &lt; len(proj_colors):\n                proj_color = proj_colors[i]\n            else:\n                proj_color = contour_color\n\n            ax[\"a\"].plot(\n                x_proj_ppm,\n                proj_x,\n                linewidth=defaults[\"linewidth_proj\"],\n                color=proj_color,\n            )\n            ax[\"a\"].axis(False)\n            ax[\"b\"].plot(\n                -proj_y,\n                y_proj_ppm,\n                linewidth=defaults[\"linewidth_proj\"],\n                color=proj_color,\n            )\n            ax[\"b\"].axis(False)\n\n        else:\n            proj_color = \"black\"\n            # Create contour plot with basic black color\n            ax[\"A\"].contour(\n                x_proj_ppm,\n                y_proj_ppm,\n                data[y_indices, x_indices],\n                contour_levels,\n                colors=\"black\",\n                linewidths=defaults[\"linewidth_contour\"],\n            )\n            ax[\"a\"].plot(\n                x_proj_ppm,\n                proj_x,\n                linewidth=defaults[\"linewidth_proj\"],\n                color=proj_color,\n            )\n            ax[\"a\"].axis(False)\n            ax[\"b\"].plot(\n                -proj_y,\n                y_proj_ppm,\n                linewidth=defaults[\"linewidth_proj\"],\n                color=proj_color,\n            )\n            ax[\"b\"].axis(False)\n        if xaxislabel := defaults.get(\"xaxislabel\"):\n            defaults[\"xaxislabel\"] = xaxislabel\n        else:\n            defaults[\"xaxislabel\"] = f\"$^{{{number_x}}}\\\\mathrm{{{nucleus_x}}}$ (ppm)\"\n\n        if \"yaxislabel\" in kwargs:\n            defaults[\"yaxislabel\"] = kwargs[\"yaxislabel\"]\n        elif yaxislabel := defaults.get(\"yaxislabel\"):\n            defaults[\"yaxislabel\"] = yaxislabel\n        else:\n            defaults[\"yaxislabel\"] = f\"$^{{{number_y}}}\\\\mathrm{{{nucleus_y}}}$ (ppm)\"\n\n        if (\n            homo\n            and \"yaxislabel\" not in kwargs\n            and \"xaxislabel\" not in kwargs\n            and defaults[\"yaxislabel\"] != defaults[\"xaxislabel\"]\n            and number_y == number_x\n            and nucleus_y == nucleus_x\n        ):\n            defaults[\"yaxislabel\"] = defaults[\"xaxislabel\"]\n\n        ax[\"A\"].set_xlabel(\n            defaults[\"xaxislabel\"],\n            fontsize=defaults[\"axisfontsize\"],\n            fontname=defaults[\"axisfont\"] if defaults[\"axisfont\"] else None,\n        )\n        ax[\"A\"].set_ylabel(\n            defaults[\"yaxislabel\"],\n            fontsize=defaults[\"axisfontsize\"],\n            fontname=defaults[\"axisfont\"] if defaults[\"axisfont\"] else None,\n        )\n        ax[\"A\"].yaxis.set_label_position(\"right\")\n        ax[\"A\"].yaxis.tick_right()\n        ax[\"A\"].tick_params(\n            axis=\"x\",\n            labelsize=defaults[\"tickfontsize\"],\n            labelfontfamily=defaults[\"tickfont\"] if defaults[\"tickfont\"] else None,\n        )\n        ax[\"A\"].tick_params(\n            axis=\"y\",\n            labelsize=defaults[\"tickfontsize\"],\n            labelfontfamily=defaults[\"tickfont\"] if defaults[\"tickfont\"] else None,\n        )\n\n        if diag is not None:\n            x_diag = np.linspace(\n                xlim[0] if xlim else ppm_x_limits[0],\n                xlim[1] if xlim else ppm_x_limits[1],\n                100,\n            )\n            y_diag = diag * x_diag\n            ax[\"A\"].plot(x_diag, y_diag, linestyle=\"--\", color=\"gray\")\n\n        if xlim:\n            ax[\"A\"].set_xlim(xlim)\n            ax[\"a\"].set_xlim(xlim)\n        if ylim:\n            ax[\"A\"].set_ylim(ylim)\n            ax[\"b\"].set_ylim(ylim)\n\n    if save:\n        if filename and format:\n            full_filename = f\"{filename}.{format}\"\n        else:\n            full_filename = f\"2d_nmr_spectrum.{format if format else 'png'}\"\n        plt.savefig(full_filename, dpi=300, bbox_inches=\"tight\", pad_inches=0.1)\n\n    if return_fig:\n        return ax\n\n    plt.show()\n    return None\n</code></pre>"},{"location":"reference/spinplots/plot.html#spinplots.plot.df2d","title":"df2d","text":"<pre><code>df2d(path, contour_start, contour_num, contour_factor, cmap=None, xlim=None, ylim=None, save=False, filename=None, format=None, return_fig=False)\n</code></pre> <p>Plot 2D NMR data from a CSV file or a DataFrame.</p> <p>Parameters: path (str): Path to the CSV file. contour_start (float): Contour start value. contour_num (int): Number of contour levels. contour_factor (float): Contour factor.</p> <p>Keyword arguments:     cmap (str): The colormap to use for the contour lines.     xlim (tuple): The limits for the x-axis.     ylim (tuple): The limits for the y-axis.     save (bool): Whether to save the plot.     filename (str): The name of the file to save the plot.     format (str): The format to save the file in.     return_fig (bool): Whether to return the figure and axis.</p> <p>Example: df2d('nmr_data.csv', contour_start=4e3, contour_num=10, contour_factor=1.2, cmap='viridis', xlim=(0, 100), ylim=(0, 100), save=True, filename='2d_spectrum', format='png')</p> Source code in <code>spinplots/plot.py</code> <pre><code>def df2d(\n    path,\n    contour_start,\n    contour_num,\n    contour_factor,\n    cmap=None,\n    xlim=None,\n    ylim=None,\n    save=False,\n    filename=None,\n    format=None,\n    return_fig=False,\n):\n    \"\"\"\n    Plot 2D NMR data from a CSV file or a DataFrame.\n\n    Parameters:\n    path (str): Path to the CSV file.\n    contour_start (float): Contour start value.\n    contour_num (int): Number of contour levels.\n    contour_factor (float): Contour factor.\n\n    Keyword arguments:\n        cmap (str): The colormap to use for the contour lines.\n        xlim (tuple): The limits for the x-axis.\n        ylim (tuple): The limits for the y-axis.\n        save (bool): Whether to save the plot.\n        filename (str): The name of the file to save the plot.\n        format (str): The format to save the file in.\n        return_fig (bool): Whether to return the figure and axis.\n\n    Example:\n    df2d('nmr_data.csv', contour_start=4e3, contour_num=10, contour_factor=1.2, cmap='viridis', xlim=(0, 100), ylim=(0, 100), save=True, filename='2d_spectrum', format='png')\n    \"\"\"\n\n    # Check if path to CSV or DataFrame\n    df_nmr = path if isinstance(path, pd.DataFrame) else pd.read_csv(path)\n\n    cols = df_nmr.columns\n    f1_nuclei, f1_units = cols[0].split()\n    number_x, nucleus_x = (\n        \"\".join(filter(str.isdigit, f1_nuclei)),\n        \"\".join(filter(str.isalpha, f1_nuclei)),\n    )\n    f2_nuclei, f2_units = cols[1].split()\n    number_y, nucleus_y = (\n        \"\".join(filter(str.isdigit, f2_nuclei)),\n        \"\".join(filter(str.isalpha, f2_nuclei)),\n    )\n    data_grid = df_nmr.pivot_table(index=cols[0], columns=cols[1], values=\"intensity\")\n    proj_f1, proj_f2 = calculate_projections(df_nmr, export=False)\n\n    f1 = data_grid.index.to_numpy()\n    f2 = data_grid.columns.to_numpy()\n    x, y = np.meshgrid(f2, f1)\n    z = data_grid.to_numpy()\n\n    contour_levels = contour_start * contour_factor ** np.arange(contour_num)\n\n    ax = plt.figure(constrained_layout=False).subplot_mosaic(\n        \"\"\"\n    .a\n    bA\n    \"\"\",\n        gridspec_kw={\n            \"height_ratios\": [0.9, 6.0],\n            \"width_ratios\": [0.8, 6.0],\n            \"wspace\": 0.03,\n            \"hspace\": 0.04,\n        },\n    )\n\n    if cmap is not None:\n        ax[\"A\"].contourf(\n            x,\n            y,\n            z,\n            contour_levels,\n            cmap=cmap,\n            norm=LogNorm(vmin=contour_levels[0], vmax=contour_levels[-1]),\n        )\n    else:\n        ax[\"A\"].contourf(\n            x,\n            y,\n            z,\n            contour_levels,\n            cmap=\"Greys\",\n            norm=LogNorm(vmin=contour_levels[0], vmax=contour_levels[-1]),\n        )\n\n    ax[\"a\"].plot(\n        proj_f2[f\"{f2_nuclei} {f2_units}\"], proj_f2[\"F2 projection\"], color=\"black\"\n    )\n    ax[\"a\"].axis(False)\n    ax[\"b\"].plot(\n        -proj_f1[\"F1 projection\"], proj_f1[f\"{f1_nuclei} {f1_units}\"], color=\"black\"\n    )\n    ax[\"b\"].axis(False)\n\n    ax[\"A\"].set_xlabel(f\"$^{{{number_y}}}\\\\mathrm{{{nucleus_y}}}$ (ppm)\", fontsize=13)\n    ax[\"A\"].set_ylabel(f\"$^{{{number_x}}}\\\\mathrm{{{nucleus_x}}}$ (ppm)\", fontsize=13)\n    ax[\"A\"].yaxis.set_label_position(\"right\")\n    ax[\"A\"].yaxis.tick_right()\n    ax[\"A\"].tick_params(axis=\"x\", labelsize=12)\n    ax[\"A\"].tick_params(axis=\"y\", labelsize=12)\n\n    if xlim:\n        ax[\"A\"].set_xlim(xlim)\n        ax[\"a\"].set_xlim(xlim)\n    if ylim:\n        ax[\"A\"].set_ylim(ylim)\n        ax[\"b\"].set_ylim(ylim)\n\n    if save:\n        if filename:\n            full_filename = filename + \".\" + format\n        else:\n            full_filename = \"2d_nmr_spectrum.\" + format\n        plt.savefig(\n            full_filename, format=format, dpi=300, bbox_inches=\"tight\", pad_inches=0.1\n        )\n        return None\n    elif return_fig:\n        return ax\n    else:\n        plt.show()\n        return None\n</code></pre>"},{"location":"reference/spinplots/plot.html#spinplots.plot.dmfit1d","title":"dmfit1d","text":"<pre><code>dmfit1d(spin_objects, color='b', linewidth=1, linestyle='-', alpha=1, model_show=True, model_color='red', model_linewidth=1, model_linestyle='--', model_alpha=1, deconv_show=True, deconv_color=None, deconv_alpha=0.3, frame=False, labels=None, labelsize=12, xlim=None, save=False, format=None, filename=None, yaxislabel=None, xaxislabel=None, axisfontsize=None, axisfont=None, tickfontsize=None, tickfont=None, tickspacing=None, return_fig=False)\n</code></pre> <p>Read a dmfit1d file and return a DataFrame with the data.</p> <p>Parameters:</p> <ul> <li> <code>spin_objects</code>               (<code>Spin</code>)           \u2013            <p>The Spin object containing the dmfit1d file.</p> </li> <li> <code>color</code>               (<code>str</code>, default:                   <code>'b'</code> )           \u2013            <p>The color of the spectrum line. The default is 'b'.</p> </li> <li> <code>linewidth</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>The width of the spectrum line. The default is 1.</p> </li> <li> <code>linestyle</code>               (<code>str</code>, default:                   <code>'-'</code> )           \u2013            <p>The style of the spectrum line. The default is '-'.</p> </li> <li> <code>alpha</code>               (<code>float</code>, default:                   <code>1</code> )           \u2013            <p>The transparency of the spectrum line. The default is 1.</p> </li> <li> <code>model_show</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to show the model line. The default is True.</p> </li> <li> <code>model_color</code>               (<code>str</code>, default:                   <code>'red'</code> )           \u2013            <p>The color of the model line. The default is 'red'.</p> </li> <li> <code>model_linewidth</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>The width of the model line. The default is 1.</p> </li> <li> <code>model_linestyle</code>               (<code>str</code>, default:                   <code>'--'</code> )           \u2013            <p>The style of the model line. The default is '--'.</p> </li> <li> <code>model_alpha</code>               (<code>float</code>, default:                   <code>1</code> )           \u2013            <p>The transparency of the model line. The default is 1.</p> </li> <li> <code>deconv_show</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to show the deconvoluted lines. The default is True.</p> </li> <li> <code>deconv_color</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>The color of the deconvoluted lines. The default is None.</p> </li> <li> <code>deconv_alpha</code>               (<code>float</code>, default:                   <code>0.3</code> )           \u2013            <p>The transparency of the deconvoluted lines. The default is 0.3.</p> </li> <li> <code>frame</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to show the frame. The default is False.</p> </li> <li> <code>labels</code>               (<code>list</code>, default:                   <code>None</code> )           \u2013            <p>The labels for the x and y axes. The default is name of columns.</p> </li> <li> <code>labelsize</code>               (<code>int</code>, default:                   <code>12</code> )           \u2013            <p>The size of the labels. The default is 12.</p> </li> <li> <code>xlim</code>               (<code>tuple</code>, default:                   <code>None</code> )           \u2013            <p>The limits for the x axis. The default is None.</p> </li> <li> <code>save</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to save the figure. The default is False.</p> </li> <li> <code>format</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>The format to save the figure. The default is None.</p> </li> <li> <code>filename</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>The name of the file to save the figure. The default is None.</p> </li> <li> <code>yaxislabel</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>The label for the y axis. The default is None.</p> </li> <li> <code>xaxislabel</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>The label for the x axis. The default is None.</p> </li> <li> <code>axisfontsize</code>               (<code>int</code>, default:                   <code>None</code> )           \u2013            <p>The size of the axis labels. The default is None.</p> </li> <li> <code>axisfont</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>The font of the axis labels. The default is None.</p> </li> <li> <code>tickfontsize</code>               (<code>int</code>, default:                   <code>None</code> )           \u2013            <p>The size of the tick labels. The default is None.</p> </li> <li> <code>tickfont</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>The font of the tick labels. The default is None.</p> </li> <li> <code>tickspacing</code>               (<code>int</code>, default:                   <code>None</code> )           \u2013            <p>The spacing of the ticks. The default is None.</p> </li> <li> <code>return_fig</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to return the figure. The default is False.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>fig</code> (              <code>Figure</code> )          \u2013            <p>The figure object.</p> </li> <li> <code>dmfit_df</code> (              <code>DataFrame</code> )          \u2013            <p>The DataFrame with the data from the dmfit1d file.</p> </li> </ul> Source code in <code>spinplots/plot.py</code> <pre><code>def dmfit1d(\n    spin_objects,\n    color=\"b\",\n    linewidth=1,\n    linestyle=\"-\",\n    alpha=1,\n    model_show=True,\n    model_color=\"red\",\n    model_linewidth=1,\n    model_linestyle=\"--\",\n    model_alpha=1,\n    deconv_show=True,\n    deconv_color=None,\n    deconv_alpha=0.3,\n    frame=False,\n    labels=None,\n    labelsize=12,\n    xlim=None,\n    save=False,\n    format=None,\n    filename=None,\n    yaxislabel=None,\n    xaxislabel=None,\n    axisfontsize=None,\n    axisfont=None,\n    tickfontsize=None,\n    tickfont=None,\n    tickspacing=None,\n    return_fig=False,\n):\n    \"\"\"\n    Read a dmfit1d file and return a DataFrame with the data.\n\n    Parameters\n    ----------\n    spin_objects : Spin\n        The Spin object containing the dmfit1d file.\n    color : str, optional\n        The color of the spectrum line. The default is 'b'.\n    linewidth : int, optional\n        The width of the spectrum line. The default is 1.\n    linestyle : str, optional\n        The style of the spectrum line. The default is '-'.\n    alpha : float, optional\n        The transparency of the spectrum line. The default is 1.\n    model_show : bool, optional\n        Whether to show the model line. The default is True.\n    model_color : str, optional\n        The color of the model line. The default is 'red'.\n    model_linewidth : int, optional\n        The width of the model line. The default is 1.\n    model_linestyle : str, optional\n        The style of the model line. The default is '--'.\n    model_alpha : float, optional\n        The transparency of the model line. The default is 1.\n    deconv_show : bool, optional\n        Whether to show the deconvoluted lines. The default is True.\n    deconv_color : str, optional\n        The color of the deconvoluted lines. The default is None.\n    deconv_alpha : float, optional\n        The transparency of the deconvoluted lines. The default is 0.3.\n\n    frame : bool, optional\n        Whether to show the frame. The default is False.\n    labels : list, optional\n        The labels for the x and y axes. The default is name of columns.\n    labelsize : int, optional\n        The size of the labels. The default is 12.\n    xlim : tuple, optional\n        The limits for the x axis. The default is None.\n    save : bool, optional\n        Whether to save the figure. The default is False.\n    format : str, optional\n        The format to save the figure. The default is None.\n    filename : str, optional\n        The name of the file to save the figure. The default is None.\n    yaxislabel : str, optional\n        The label for the y axis. The default is None.\n    xaxislabel : str, optional\n        The label for the x axis. The default is None.\n    axisfontsize : int, optional\n        The size of the axis labels. The default is None.\n    axisfont : str, optional\n        The font of the axis labels. The default is None.\n    tickfontsize : int, optional\n        The size of the tick labels. The default is None.\n    tickfont : str, optional\n        The font of the tick labels. The default is None.\n    tickspacing : int, optional\n        The spacing of the ticks. The default is None.\n    return_fig : bool, optional\n        Whether to return the figure. The default is False.\n\n    Returns\n    -------\n    fig : matplotlib.figure.Figure\n        The figure object.\n    dmfit_df : pandas.DataFrame\n        The DataFrame with the data from the dmfit1d file.\n\n    \"\"\"\n\n    if not spin_objects.spectrum:\n        raise ValueError(\"Spin object contains no spectra.\")\n\n    spectrum_info = spin_objects.spectrum\n    dmfit_df = spectrum_info.get(\"dmfit_dataframe\")\n\n    if dmfit_df is None:\n        raise ValueError(\n            \"DMfit DataFrame not found in Spin object. Read data with provider='dmfit'\"\n        )\n\n    n_lines = sum(col.startswith(\"Line#\") for col in dmfit_df.columns)\n\n    defaults = {\n        \"color\": color,\n        \"linewidth\": linewidth,\n        \"linestyle\": linestyle,\n        \"alpha\": alpha,\n        \"model_show\": model_show,\n        \"model_color\": model_color,\n        \"model_linewidth\": model_linewidth,\n        \"model_linestyle\": model_linestyle,\n        \"model_alpha\": model_alpha,\n        \"deconv_show\": deconv_show,\n        \"deconv_color\": deconv_color,\n        \"deconv_alpha\": deconv_alpha,\n        \"frame\": frame,\n        \"labels\": labels,\n        \"labelsize\": labelsize,\n        \"xlim\": xlim,\n        \"save\": save,\n        \"format\": format,\n        \"filename\": filename,\n        \"yaxislabel\": yaxislabel,\n        \"xaxislabel\": xaxislabel,\n        \"axisfontsize\": axisfontsize,\n        \"axisfont\": axisfont,\n        \"tickfontsize\": tickfontsize,\n        \"tickfont\": tickfont,\n        \"tickspacing\": tickspacing,\n        \"return_fig\": return_fig,\n    }\n\n    params = {k: v for k, v in locals().items() if k in defaults and v is not None}\n    params.update(defaults)\n\n    fig, ax = plt.subplots()\n    ax.plot(\n        dmfit_df[\"ppm\"],\n        dmfit_df[\"Spectrum\"],\n        color=params[\"color\"],\n        linewidth=params[\"linewidth\"],\n        linestyle=params[\"linestyle\"],\n        alpha=params[\"alpha\"],\n        label=params[\"labels\"][0]\n        if params[\"labels\"] and len(params[\"labels\"]) &gt; 0\n        else None,\n    )\n    if params[\"model_show\"]:\n        ax.plot(\n            dmfit_df[\"ppm\"],\n            dmfit_df[\"Model\"],\n            color=params[\"model_color\"],\n            linewidth=params[\"model_linewidth\"],\n            linestyle=params[\"model_linestyle\"],\n            alpha=params[\"model_alpha\"],\n            label=params[\"labels\"][1]\n            if params[\"labels\"] and len(params[\"labels\"]) &gt; 1\n            else None,\n        )\n    if params[\"deconv_show\"]:\n        for i in range(1, n_lines + 1):\n            if params[\"deconv_color\"] is not None:\n                ax.fill_between(\n                    dmfit_df[\"ppm\"],\n                    dmfit_df[f\"Line#{i}\"],\n                    alpha=params[\"deconv_alpha\"],\n                    color=params[\"deconv_color\"],\n                )\n            else:\n                ax.fill_between(\n                    dmfit_df[\"ppm\"], dmfit_df[f\"Line#{i}\"], alpha=params[\"deconv_alpha\"]\n                )\n\n    if params[\"labels\"]:\n        ax.legend(\n            bbox_to_anchor=(1.05, 1),\n            loc=\"upper left\",\n            fontsize=defaults[\"labelsize\"],\n            prop={\"family\": defaults[\"tickfont\"], \"size\": defaults[\"labelsize\"]},\n        )\n    if params[\"xlim\"]:\n        ax.set_xlim(params[\"xlim\"])\n    if params[\"yaxislabel\"]:\n        ax.set_ylabel(params[\"yaxislabel\"], fontsize=params[\"labelsize\"])\n    if params[\"xaxislabel\"]:\n        ax.set_xlabel(params[\"xaxislabel\"], fontsize=params[\"labelsize\"])\n    if params[\"axisfontsize\"]:\n        ax.xaxis.label.set_size(params[\"axisfontsize\"])\n        ax.yaxis.label.set_size(params[\"axisfontsize\"])\n    if params[\"axisfont\"]:\n        ax.xaxis.label.set_fontname(params[\"axisfont\"])\n        ax.yaxis.label.set_fontname(params[\"axisfont\"])\n    if params[\"tickfontsize\"]:\n        ax.tick_params(axis=\"both\", which=\"major\", labelsize=params[\"tickfontsize\"])\n        ax.tick_params(axis=\"both\", which=\"minor\", labelsize=params[\"tickfontsize\"])\n    if params[\"tickfont\"]:\n        ax.tick_params(axis=\"both\", which=\"major\", labelfont=params[\"tickfont\"])\n        ax.tick_params(axis=\"both\", which=\"minor\", labelfont=params[\"tickfont\"])\n    if params[\"tickspacing\"]:\n        ax.xaxis.set_major_locator(plt.MultipleLocator(params[\"tickspacing\"]))\n        ax.yaxis.set_major_locator(plt.MultipleLocator(params[\"tickspacing\"]))\n    if params[\"frame\"]:\n        ax.spines[\"top\"].set_visible(True)\n        ax.spines[\"right\"].set_visible(True)\n        ax.spines[\"left\"].set_visible(True)\n    else:\n        ax.spines[\"top\"].set_visible(False)\n        ax.spines[\"right\"].set_visible(False)\n        ax.spines[\"left\"].set_visible(False)\n        ax.yaxis.set_ticks([])\n        ax.yaxis.set_ticklabels([])\n    if params[\"save\"]:\n        if params[\"format\"]:\n            plt.savefig(\n                f\"{params['filename']}.{params['format']}\", format=params[\"format\"]\n            )\n        else:\n            plt.savefig(params[\"filename\"])\n\n    if params[\"return_fig\"]:\n        return fig, ax\n    else:\n        plt.show()\n        return None\n</code></pre>"},{"location":"reference/spinplots/plot.html#spinplots.plot.dmfit2d","title":"dmfit2d","text":"<pre><code>dmfit2d(spin_objects, contour_start=100000.0, contour_num=10, contour_factor=1.2, colors=None, proj_colors=None, xlim=None, ylim=None, labels=None, save=False, filename=None, format=None, axis_right=True, diag=None, return_fig=False, **kwargs)\n</code></pre> <p>Plot 2D DMFit data with 1D projections.</p> <p>Parameters:</p> <ul> <li> <code>spin_objects</code>               (<code>Spin or SpinCollection</code>)           \u2013            <p>The Spin object or SpinCollection containing DMFit 2D data.</p> </li> <li> <code>contour_start</code>               (<code>float</code>, default:                   <code>100000.0</code> )           \u2013            <p>The starting contour level. Default is 1e5.</p> </li> <li> <code>contour_num</code>               (<code>int</code>, default:                   <code>10</code> )           \u2013            <p>The number of contour levels. Default is 10.</p> </li> <li> <code>contour_factor</code>               (<code>float</code>, default:                   <code>1.2</code> )           \u2013            <p>The factor by which the contour levels increase. Default is 1.2.</p> </li> <li> <code>colors</code>               (<code>str or list</code>, default:                   <code>None</code> )           \u2013            <p>Color(s) for each spectrum's contours.</p> </li> <li> <code>proj_colors</code>               (<code>str or list</code>, default:                   <code>None</code> )           \u2013            <p>Color(s) for each spectrum's projections.</p> </li> <li> <code>xlim</code>               (<code>tuple</code>, default:                   <code>None</code> )           \u2013            <p>The limits for the x-axis (F2).</p> </li> <li> <code>ylim</code>               (<code>tuple</code>, default:                   <code>None</code> )           \u2013            <p>The limits for the y-axis (F1).</p> </li> <li> <code>labels</code>               (<code>list</code>, default:                   <code>None</code> )           \u2013            <p>Labels for the spectra in the legend.</p> </li> <li> <code>save</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to save the plot.</p> </li> <li> <code>filename</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>Name for the saved file.</p> </li> <li> <code>format</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>Format for the saved file.</p> </li> <li> <code>axis_right</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to put the y-axis on the right.</p> </li> <li> <code>diag</code>               (<code>float or None</code>, default:                   <code>None</code> )           \u2013            <p>Slope of the diagonal line.</p> </li> <li> <code>return_fig</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to return the figure and axes dictionary.</p> </li> <li> <code>**kwargs</code>               (<code>dict</code>, default:                   <code>{}</code> )           \u2013            <p>Additional keyword arguments:</p> <ul> <li>labelsize : int     Size of labels in the legend.</li> <li>linewidth_contour : float     Width of contour lines.</li> <li>linewidth_proj : float     Width of projection lines.</li> <li>alpha : float     Transparency of contours.</li> <li>xaxislabel : str     Custom label for x-axis (f1).</li> <li>yaxislabel : str     Custom label for y-axis (f2).</li> <li>axisfontsize : int     Font size for axis labels.</li> <li>axisfont : str     Font family for axis labels.</li> <li>tickfontsize : int     Font size for tick labels.</li> <li>tickfont : str     Font family for tick labels.</li> </ul> </li> </ul> <p>Returns:</p> <ul> <li> <code>fig</code> (              <code>(Figure, optional)</code> )          \u2013            <p>The figure object, if return_fig is True.</p> </li> <li> <code>ax_dict</code> (              <code>dict of matplotlib.axes.Axes, optional</code> )          \u2013            <p>Dictionary of axes objects (e.g., 'A', 'a', 'b'), if return_fig is True.</p> </li> </ul> Source code in <code>spinplots/plot.py</code> <pre><code>def dmfit2d(\n    spin_objects,\n    contour_start=1e5,\n    contour_num=10,\n    contour_factor=1.2,\n    colors=None,\n    proj_colors=None,\n    xlim=None,\n    ylim=None,\n    labels=None,\n    save=False,\n    filename=None,\n    format=None,\n    axis_right=True,\n    diag=None,\n    return_fig=False,\n    **kwargs,\n):\n    \"\"\"\n    Plot 2D DMFit data with 1D projections.\n\n    Parameters\n    ----------\n    spin_objects : Spin or SpinCollection\n        The Spin object or SpinCollection containing DMFit 2D data.\n    contour_start : float, optional\n        The starting contour level. Default is 1e5.\n    contour_num : int, optional\n        The number of contour levels. Default is 10.\n    contour_factor : float, optional\n        The factor by which the contour levels increase. Default is 1.2.\n    colors : str or list, optional\n        Color(s) for each spectrum's contours.\n    proj_colors : str or list, optional\n        Color(s) for each spectrum's projections.\n    xlim : tuple, optional\n        The limits for the x-axis (F2).\n    ylim : tuple, optional\n        The limits for the y-axis (F1).\n    labels : list, optional\n        Labels for the spectra in the legend.\n    save : bool, optional\n        Whether to save the plot.\n    filename : str, optional\n        Name for the saved file.\n    format : str, optional\n        Format for the saved file.\n    axis_right : bool, optional\n        Whether to put the y-axis on the right.\n    diag : float or None, optional\n        Slope of the diagonal line.\n    return_fig : bool, optional\n        Whether to return the figure and axes dictionary.\n    **kwargs : dict, optional\n        Additional keyword arguments:\n\n        - labelsize : int\n            Size of labels in the legend.\n        - linewidth_contour : float\n            Width of contour lines.\n        - linewidth_proj : float\n            Width of projection lines.\n        - alpha : float\n            Transparency of contours.\n        - xaxislabel : str\n            Custom label for x-axis (f1).\n        - yaxislabel : str\n            Custom label for y-axis (f2).\n        - axisfontsize : int\n            Font size for axis labels.\n        - axisfont : str\n            Font family for axis labels.\n        - tickfontsize : int\n            Font size for tick labels.\n        - tickfont : str\n            Font family for tick labels.\n\n    Returns\n    -------\n    fig : matplotlib.figure.Figure, optional\n        The figure object, if return_fig is True.\n    ax_dict : dict of matplotlib.axes.Axes, optional\n        Dictionary of axes objects (e.g., 'A', 'a', 'b'), if return_fig is True.\n    \"\"\"\n    from matplotlib.lines import Line2D\n\n    defaults = DEFAULTS.copy()\n    defaults.update(\n        {k: v for k, v in kwargs.items() if k in defaults and v is not None}\n    )\n\n    if hasattr(spin_objects, \"spins\"):\n        spectra_dicts = [spin.spectrum for spin in spin_objects.spins]\n        if labels is None:\n            plot_labels = [\n                spin.tag if spin.tag else f\"Spectrum {idx + 1}\"\n                for idx, spin in enumerate(spin_objects.spins)\n            ]\n        else:\n            plot_labels = labels\n    else:\n        spectra_dicts = [spin_objects.spectrum]\n        if labels is None:\n            plot_labels = [spin_objects.tag if spin_objects.tag else \"Spectrum\"]\n        else:\n            plot_labels = labels\n\n    if not all(s[\"ndim\"] == 2 for s in spectra_dicts):\n        raise ValueError(\"All spectra must be 2D.\")\n    if not all(s[\"metadata\"][\"provider_type\"] == \"dmfit\" for s in spectra_dicts):\n        raise ValueError(\"All spectra must be from DMFit provider.\")\n\n    num_spectra = len(spectra_dicts)\n    default_colors = [\n        \"black\",\n        \"red\",\n        \"green\",\n        \"orange\",\n        \"purple\",\n        \"brown\",\n        \"pink\",\n        \"gray\",\n        \"olive\",\n        \"cyan\",\n    ]\n\n    contour_colors_list = []\n    if isinstance(colors, str):\n        contour_colors_list = [colors] * num_spectra\n    elif isinstance(colors, list):\n        contour_colors_list = [colors[i % len(colors)] for i in range(num_spectra)]\n    else:\n        contour_colors_list = [\n            default_colors[i % len(default_colors)] for i in range(num_spectra)\n        ]\n\n    projection_colors_list = []\n    if isinstance(proj_colors, str):\n        projection_colors_list = [proj_colors] * num_spectra\n    elif isinstance(proj_colors, list):\n        projection_colors_list = [\n            proj_colors[i % len(proj_colors)] for i in range(num_spectra)\n        ]\n    else:\n        projection_colors_list = contour_colors_list\n\n    fig = plt.figure(constrained_layout=False, figsize=(8, 7))\n    ax_dict = fig.subplot_mosaic(\n        \"\"\"\n        .a\n        bA\n        \"\"\",\n        gridspec_kw={\n            \"height_ratios\": [0.9, 6.0],\n            \"width_ratios\": [0.8, 6.0],\n            \"wspace\": 0.03,\n            \"hspace\": 0.04,\n        },\n    )\n    main_ax = ax_dict[\"A\"]\n    proj_ax_f2 = ax_dict[\"a\"]\n    proj_ax_f1 = ax_dict[\"b\"]\n\n    legend_elements = []\n\n    for i, spectrum_dict in enumerate(spectra_dicts):\n        data = spectrum_dict[\"data\"]\n        y_axis_f1 = spectrum_dict[\"ppm_scale\"][0]\n        x_axis_f2 = spectrum_dict[\"ppm_scale\"][1]\n\n        proj_f1_data = spectrum_dict[\"projections\"][\"f1\"]\n        proj_f2_data = spectrum_dict[\"projections\"][\"f2\"]\n\n        current_contour_color = contour_colors_list[i]\n        current_proj_color = projection_colors_list[i]\n\n        contour_levels = contour_start * contour_factor ** np.arange(contour_num)\n\n        main_ax.contour(\n            x_axis_f2,\n            y_axis_f1,\n            data,\n            levels=contour_levels,\n            colors=current_contour_color,\n            linewidths=defaults[\"linewidth_contour\"],\n            alpha=defaults[\"alpha\"],\n        )\n\n        proj_ax_f2.plot(\n            x_axis_f2,\n            proj_f2_data,\n            color=current_proj_color,\n            linewidth=defaults[\"linewidth_proj\"],\n        )\n        proj_ax_f1.plot(\n            -proj_f1_data,\n            y_axis_f1,\n            color=current_proj_color,\n            linewidth=defaults[\"linewidth_proj\"],\n        )\n\n        if i &lt; len(plot_labels) and plot_labels[i] is not None:\n            legend_elements.append(\n                Line2D(\n                    [0], [0], color=current_contour_color, lw=2, label=plot_labels[i]\n                )\n            )\n\n    first_spectrum_nuclei = spectra_dicts[0].get(\"nuclei\", [\"Unknown\", \"Unknown\"])\n    if isinstance(first_spectrum_nuclei, str):\n        first_spectrum_nuclei = [first_spectrum_nuclei, first_spectrum_nuclei]\n\n    f2_nuc_str = str(first_spectrum_nuclei[1])\n    f1_nuc_str = str(first_spectrum_nuclei[0])\n\n    num_f2, nuc_f2 = (\n        \"\".join(filter(str.isdigit, f2_nuc_str)),\n        \"\".join(filter(str.isalpha, f2_nuc_str)),\n    )\n    num_f1, nuc_f1 = (\n        \"\".join(filter(str.isdigit, f1_nuc_str)),\n        \"\".join(filter(str.isalpha, f1_nuc_str)),\n    )\n\n    final_xaxislabel = (\n        defaults.get(\"xaxislabel\")\n        if defaults.get(\"xaxislabel\")\n        else f\"$^{{{num_f2}}}${nuc_f2} (ppm)\"\n    )\n    final_yaxislabel = (\n        defaults.get(\"yaxislabel\")\n        if defaults.get(\"yaxislabel\")\n        else f\"$^{{{num_f1}}}${nuc_f1} (ppm)\"\n    )\n\n    main_ax.set_xlabel(\n        final_xaxislabel,\n        fontsize=defaults[\"axisfontsize\"],\n        fontname=defaults[\"axisfont\"],\n    )\n    main_ax.set_ylabel(\n        final_yaxislabel,\n        fontsize=defaults[\"axisfontsize\"],\n        fontname=defaults[\"axisfont\"],\n    )\n\n    main_ax.tick_params(\n        axis=\"x\",\n        labelsize=defaults[\"tickfontsize\"],\n        labelfontfamily=defaults[\"tickfont\"],\n    )\n    main_ax.tick_params(\n        axis=\"y\",\n        labelsize=defaults[\"tickfontsize\"],\n        labelfontfamily=defaults[\"tickfont\"],\n    )\n\n    if axis_right:\n        main_ax.yaxis.set_label_position(\"right\")\n        main_ax.yaxis.tick_right()\n\n    proj_ax_f2.axis(False)\n    proj_ax_f1.axis(False)\n\n    if xlim:\n        main_ax.set_xlim(xlim)\n    else:\n        current_xlim_main = main_ax.get_xlim()\n        if current_xlim_main[0] &lt; current_xlim_main[1]:\n            main_ax.set_xlim(current_xlim_main[::-1])\n    proj_ax_f2.set_xlim(main_ax.get_xlim())\n\n    if ylim:\n        main_ax.set_ylim(ylim)\n    else:\n        current_ylim_main = main_ax.get_ylim()\n        if current_ylim_main[0] &lt; current_ylim_main[1]:\n            main_ax.set_ylim(current_ylim_main[::-1])\n    proj_ax_f1.set_ylim(main_ax.get_ylim())\n\n    if diag is not None:\n        diag_xlim_eff = main_ax.get_xlim()\n        x_diag_vals = np.linspace(diag_xlim_eff[0], diag_xlim_eff[1], 100)\n        main_ax.plot(x_diag_vals, diag * x_diag_vals, \"k--\", lw=1)\n\n    if legend_elements:\n        main_ax.legend(\n            handles=legend_elements,\n            fontsize=defaults[\"labelsize\"],\n            prop={\"family\": defaults[\"tickfont\"]},\n        )\n\n    plt.tight_layout(pad=0.5)\n\n    # --- Save/Show ---\n    if save:\n        if filename and format:\n            full_filename = f\"{filename}.{format}\"\n        elif filename:\n            full_filename = f\"{filename}.png\"\n        else:\n            full_filename = f\"dmfit_2d_projections.{format if format else 'png'}\"\n        fig.savefig(full_filename, dpi=300, bbox_inches=\"tight\", pad_inches=0.1)\n\n    if return_fig:\n        return fig, ax_dict\n\n    if not save:\n        plt.show()\n\n    return None\n</code></pre>"},{"location":"reference/spinplots/spin.html","title":"spin","text":""},{"location":"reference/spinplots/spin.html#spinplots.spin.Spin","title":"Spin","text":"<pre><code>Spin(spectrum_data, provider, tag=None)\n</code></pre> <p>Represents one or more processed NMR datasets ready for plotting.</p> <p>Attributes:     spectrum (dict): A dictionary containing the data                     and metadata for a single spectrum. Keys include:                     'data' (raw), 'norm_max', 'norm_scans',                     'ppm_scale', 'hz_scale', 'nuclei', 'ndim',                     'metadata', 'projections', 'path'.     provider (str): The source of the NMR data (e.g., 'bruker')..     ndim (int): The number of dimensions of the spectrum.     tag (str): A tag for the spectrum, used for identification.</p> Source code in <code>spinplots/spin.py</code> <pre><code>def __init__(\n    self,\n    spectrum_data: dict,\n    provider: str,\n    tag: str | None = None,\n):\n    if not spectrum_data:\n        raise ValueError(\"Cannot initialize Spin object with empty spectrum data.\")\n\n    ndim = spectrum_data[\"ndim\"]\n    if ndim not in [1, 2]:\n        raise ValueError(\n            f\"Unsupported number of dimensions in data: {ndim}. \"\n            \"Only 1D and 2D spectra are supported.\"\n        )\n\n    provider = provider.lower()\n    if provider not in [\"bruker\", \"dmfit\"]:\n        raise ValueError(\n            f\"Unsupported provider: {provider}. \"\n            \"Only 'bruker' and 'dmfit' are supported.\"\n        )\n\n    self.spectrum = spectrum_data\n    self.provider = provider\n    self.ndim = ndim\n    self.tag = tag\n</code></pre>"},{"location":"reference/spinplots/spin.html#spinplots.spin.Spin.plot","title":"plot","text":"<pre><code>plot(grid=None, **kwargs)\n</code></pre> <p>Generates a plot of the NMR data stored in this object.</p> <p>Args:     grid (str, optional): Grid layout in format 'rows x cols' (e.g., '2x2', '1x3').             If provided, spectra will be plotted in a grid layout.     **kwargs: Plotting keyword arguments specific to the plot type             (e.g., xlim, labels, color, contour_start, etc.).             These are passed to the underlying plotting function.</p> <p>Returns:     The result from the underlying plotting function.</p> Source code in <code>spinplots/spin.py</code> <pre><code>def plot(self, grid=None, **kwargs):\n    \"\"\"\n    Generates a plot of the NMR data stored in this object.\n\n    Args:\n        grid (str, optional): Grid layout in format 'rows x cols' (e.g., '2x2', '1x3').\n                If provided, spectra will be plotted in a grid layout.\n        **kwargs: Plotting keyword arguments specific to the plot type\n                (e.g., xlim, labels, color, contour_start, etc.).\n                These are passed to the underlying plotting function.\n\n    Returns:\n        The result from the underlying plotting function.\n    \"\"\"\n\n    subplot_dims = None\n    if grid:\n        try:\n            rows, cols = map(int, grid.lower().split(\"x\"))\n        except (ValueError, AttributeError, TypeError) as e:\n            raise ValueError(\n                f\"Grid format should be 'rows x cols' (e.g., '2x2', '1x3'), got {grid}\"\n            ) from e\n        subplot_dims = (rows, cols)\n\n    match (self.provider, self.ndim, subplot_dims):\n        case (\"bruker\", 1, None):\n            return spinplot.bruker1d([self.spectrum], **kwargs)\n        case (\"bruker\", 2, None):\n            return spinplot.bruker2d([self.spectrum], **kwargs)\n        case (\"bruker\", 1, tuple()):\n            return spinplot.bruker1d_grid(\n                [self.spectrum], subplot_dims=subplot_dims, **kwargs\n            )\n        case (\"bruker\", 2, tuple()):\n            raise ValueError(\"Grid layout is not supported for 2D spectra.\")\n        case (\"dmfit\", 1, None):\n            return spinplot.dmfit1d(self, **kwargs)\n        case (\"dmfit\", 2, None):\n            return spinplot.dmfit2d(self, **kwargs)\n        case (\"dmfit\", 1, tuple()):\n            raise ValueError(\"Grid layout is not supported for 1D DMFit spectra.\")\n        case (\"dmfit\", 2, tuple()):\n            raise ValueError(\"Grid layout is not supported for 2D DMFit spectra.\")\n        case _:\n            raise ValueError(\n                f\"Plotting not supported for provider: {self.provider} with ndim={self.ndim}\"\n            )\n</code></pre>"},{"location":"reference/spinplots/spin.html#spinplots.spin.SpinCollection","title":"SpinCollection","text":"<pre><code>SpinCollection(spins)\n</code></pre> <p>Represents a collection of Spin objects that can be plotted together.</p> <p>Attributes:     spins (list[Spin]): A list of Spin objects.</p> Source code in <code>spinplots/spin.py</code> <pre><code>def __init__(self, spins: list[Spin]):\n    if not spins:\n        raise ValueError(\n            \"Cannot initialize SpinCollection with empty list of Spins.\"\n        )\n\n    self.spins = spins\n</code></pre>"},{"location":"reference/spinplots/spin.html#spinplots.spin.SpinCollection.plot","title":"plot","text":"<pre><code>plot(grid=None, **kwargs)\n</code></pre> <p>Generates a plot for all the Spin objects in this collection.</p> <p>Args:     grid (str, optional): Grid layout in format 'rows x cols' (e.g., '2x2', '1x3').             If provided, spectra will be plotted in a grid layout.     **kwargs: Plotting keyword arguments specific to the plot type             (e.g., xlim, labels, color, contour_start, etc.).             These are passed to the underlying plotting function.</p> <p>Returns:     The result from the underlying plotting function.</p> Source code in <code>spinplots/spin.py</code> <pre><code>def plot(self, grid=None, **kwargs):\n    \"\"\"\n    Generates a plot for all the Spin objects in this collection.\n\n    Args:\n        grid (str, optional): Grid layout in format 'rows x cols' (e.g., '2x2', '1x3').\n                If provided, spectra will be plotted in a grid layout.\n        **kwargs: Plotting keyword arguments specific to the plot type\n                (e.g., xlim, labels, color, contour_start, etc.).\n                These are passed to the underlying plotting function.\n\n    Returns:\n        The result from the underlying plotting function.\n    \"\"\"\n    # Check if all spins are of the same type (provider and ndim)\n    all_providers = all(\n        spin.provider == self.spins[0].provider for spin in self.spins\n    )\n    all_ndim = all(spin.ndim == self.spins[0].ndim for spin in self.spins)\n\n    if not (all_providers and all_ndim):\n        raise ValueError(\n            \"All Spin objects in the collection must have the same provider and ndim for plotting.\"\n        )\n\n    provider = self.spins[0].provider\n    ndim = self.spins[0].ndim\n\n    subplot_dims = None\n    if grid:\n        try:\n            rows, cols = map(int, grid.lower().split(\"x\"))\n        except (ValueError, AttributeError, TypeError) as e:\n            raise ValueError(\n                f\"Grid format should be 'rows x cols' (e.g., '2x2', '1x3'), got {grid}\"\n            ) from e\n        subplot_dims = (rows, cols)\n\n    spectra = [spin.spectrum for spin in self.spins]\n\n    match (provider, ndim, subplot_dims):\n        case (\"bruker\", 1, None):\n            return spinplot.bruker1d(spectra, **kwargs)\n        case (\"bruker\", 2, None):\n            return spinplot.bruker2d(spectra, **kwargs)\n        case (\"bruker\", 1, tuple()):\n            return spinplot.bruker1d_grid(\n                spectra, subplot_dims=subplot_dims, **kwargs\n            )\n        case (\"bruker\", 2, tuple()):\n            raise ValueError(\"Grid layout is not supported for 2D spectra.\")\n        case (\"dmfit\", 1, None):\n            return spinplot.dmfit1d(self, **kwargs)\n        case (\"dmfit\", 2, None):\n            return spinplot.dmfit2d(self, **kwargs)\n        case (\"dmfit\", 1, tuple()):\n            raise ValueError(\"Grid layout is not supported for 1D DMFit spectra.\")\n        case (\"dmfit\", 2, tuple()):\n            raise ValueError(\"Grid layout is not supported for 2D DMFit spectra.\")\n        case _:\n            raise ValueError(\n                f\"Plotting not supported for provider: {provider} with ndim={ndim}\"\n            )\n</code></pre>"},{"location":"reference/spinplots/utils.html","title":"utils","text":""},{"location":"reference/spinplots/utils.html#spinplots.utils.calculate_projections","title":"calculate_projections","text":"<pre><code>calculate_projections(data, export=False, filename=None)\n</code></pre> <p>Calculate F1 and F2 projections from a DataFrame or a CSV file.</p> <p>Parameters: data (pd.DataFrame or str): DataFrame or path to a CSV file. export (bool): If True, export the projections to a CSV file. Default is False. filename (str): Name of the exported CSV file. Default is 'projections_f1.csv' and 'projections_f2.csv'.</p> <p>Returns: pd.DataFrame: DataFrame containing the F1 and F2 projections.</p> Source code in <code>spinplots/utils.py</code> <pre><code>def calculate_projections(data, export=False, filename=None):\n    \"\"\"\n    Calculate F1 and F2 projections from a DataFrame or a CSV file.\n\n    Parameters:\n    data (pd.DataFrame or str): DataFrame or path to a CSV file.\n    export (bool): If True, export the projections to a CSV file. Default is False.\n    filename (str): Name of the exported CSV file. Default is 'projections_f1.csv'\n    and 'projections_f2.csv'.\n\n    Returns:\n    pd.DataFrame: DataFrame containing the F1 and F2 projections.\n    \"\"\"\n    if isinstance(data, str):\n        df_nmr = pd.read_csv(data)\n    elif isinstance(data, pd.DataFrame):\n        df_nmr = data\n    else:\n        raise ValueError(\"Data must be a DataFrame or a path to a CSV file.\")\n\n    cols = df_nmr.columns\n    f1_nuclei, f1_units = cols[0].split()\n    f2_nuclei, f2_units = cols[1].split()\n    data = (\n        df_nmr[\"intensity\"]\n        .to_numpy()\n        .reshape(len(df_nmr[cols[0]].unique()), len(df_nmr[cols[1]].unique()))\n    )\n\n    f1_proj = np.max(data, axis=1)\n    f2_proj = np.max(data, axis=0)\n\n    # Define df_pos that might have different sizes\n    df_f1 = pd.DataFrame(\n        {\n            f\"{f1_nuclei} {f1_units}\": df_nmr[cols[0]].unique(),\n            \"F1 projection\": f1_proj,\n        }\n    )\n\n    df_f2 = pd.DataFrame(\n        {\n            f\"{f2_nuclei} {f2_units}\": df_nmr[cols[1]].unique(),\n            \"F2 projection\": f2_proj,\n        }\n    )\n\n    if export:\n        if filename is None:\n            filename = \"projections\"\n        df_f1.to_csv(f\"{filename}_f1.csv\", index=False)\n        df_f2.to_csv(f\"{filename}_f2.csv\", index=False)\n    elif not export:\n        return df_f1, df_f2\n\n    return None, None\n</code></pre>"},{"location":"reference/spinplots/utils.html#spinplots.utils.nmr_df","title":"nmr_df","text":"<pre><code>nmr_df(data_path, hz=False, export=False, filename=None)\n</code></pre> <p>Reads Bruker's NMR 1D and 2D data and converts it into a pandas DataFrame.</p> <p>Parameters: data_path (str): Path to the NMR data. hz (bool): If True, use Hz scale instead of ppm scale. Default is False. export (bool): If True, export the DataFrame to a CSV file. Default is False. filename (str): Name of the exported CSV file. Default is 'nmr_data.csv'.</p> <p>Returns: pd.DataFrame: DataFrame containing the NMR data.</p> Source code in <code>spinplots/utils.py</code> <pre><code>def nmr_df(data_path, hz=False, export=False, filename=None):\n    \"\"\"\n    Reads Bruker's NMR 1D and 2D data and converts it into a pandas DataFrame.\n\n    Parameters:\n    data_path (str): Path to the NMR data.\n    hz (bool): If True, use Hz scale instead of ppm scale. Default is False.\n    export (bool): If True, export the DataFrame to a CSV file. Default is False.\n    filename (str): Name of the exported CSV file. Default is\n    'nmr_data.csv'.\n\n    Returns:\n    pd.DataFrame: DataFrame containing the NMR data.\n    \"\"\"\n    dic, data = ng.bruker.read_pdata(data_path)\n    udic = ng.bruker.guess_udic(dic, data)\n    ndim = udic[\"ndim\"]\n\n    if ndim == 1:\n        nuclei = udic[0][\"label\"]\n        uc = ng.fileiobase.uc_from_udic(udic, dim=0)\n        ppm = uc.ppm_scale()\n        hz = uc.hz_scale()\n        ndata = data / np.max(data)\n        df_nmr = pd.DataFrame(\n            {\n                \"hz\": hz,\n                \"ppm\": ppm,\n                \"intensity\": data,\n                \"norm_intensity\": ndata,\n                \"nuclei\": nuclei,\n            }\n        )\n        df_nmr.attrs[\"nmr_dim\"] = ndim\n    elif ndim == 2:\n        nuclei = [udic[0][\"label\"], udic[1][\"label\"]]\n        uc_f1 = ng.fileiobase.uc_from_udic(udic, dim=0)\n        uc_f2 = ng.fileiobase.uc_from_udic(udic, dim=1)\n        ppm_f1 = uc_f1.ppm_scale()\n        ppm_f2 = uc_f2.ppm_scale()\n        hz_f1 = uc_f1.hz_scale()\n        hz_f2 = uc_f2.hz_scale()\n\n        if hz:\n            F1_hz, F2_hz = np.meshgrid(hz_f1, hz_f2, indexing=\"ij\")\n            df_nmr = pd.DataFrame(\n                {\n                    f\"{nuclei[0]} hz\": F1_hz.flatten(),\n                    f\"{nuclei[1]} hz\": F2_hz.flatten(),\n                    \"intensity\": data.flatten(),\n                }\n            )\n\n        else:\n            F1_ppm, F2_ppm = np.meshgrid(ppm_f1, ppm_f2, indexing=\"ij\")\n            df_nmr = pd.DataFrame(\n                {\n                    f\"{nuclei[0]} ppm\": F1_ppm.flatten(),\n                    f\"{nuclei[1]} ppm\": F2_ppm.flatten(),\n                    \"intensity\": data.flatten(),\n                }\n            )\n\n        df_nmr.attrs[\"nmr_dim\"] = ndim\n    else:\n        raise ValueError(\"Only 1D and 2D NMR data are supported.\")\n\n    if export:\n        if filename is None:\n            filename = \"nmr_data.csv\"\n        df_nmr.to_csv(filename, index=False)\n        return None\n    elif not export:\n        return df_nmr\n    return None\n</code></pre>"},{"location":"user_guide/dmfit_plots.html","title":"Plot DMFit Results","text":"<p><code>SpinPlots</code> provides functionality to easily plot fits of NMR data done using DMfit.</p> <p>To use <code>Spinplots</code> functions, you first need to export your 1D <code>DMFit</code> data, as follows:</p> <ol> <li>Navigate to the menu: <code>Decomposition \u2192 Export spec, model with all lines \u2192 Export as Ascii File</code>.</li> <li>Important: Ensure the file extension is either <code>.hz</code> (for data in Hz) or <code>.ppm</code> (for data in ppm).</li> </ol> <p>The example below used data exported from a DMFit example showing a <sup>31</sup>P NMR spectrum showing overlapping peaks.</p> <pre><code>from __future__ import annotations\nimport warnings\nwarnings.filterwarnings(\"ignore\", category=UserWarning)\n\nfrom spinplots.io import read_nmr\n\ndmfit_data = read_nmr(\"../../data/DMFit/overlapping_spe_fit.ppm\",\n                      provider=\"dmfit\")\ndmfit_data.plot(xlim=(120, -70))\n</code></pre> <pre><code>dmfit_data.plot(\n    xlim=(120, -70),\n    xaxislabel=\"$^{31}$P (ppm)\",    # Add a label to the x-axis\n    linewidth=2,                    # Increase with of spectrum\n    model_linewidth=3,              # Increase with of model\n    model_linestyle='-.',           # Change the linestyle of the model\n    model_color='orange',           # Change the color of the model\n    model_alpha=0.8,                # Transparency of the model\n    deconv_show=False,              # Hide the deconvolution curves\n    deconv_alpha=0,                 # Transparency of the deconvolution\n    labels=[\"Spectrum\", \"Model\"],  # Add a legend\n)\n</code></pre> <p>DMFit also allows fitting of 2D NMR spectra such as this \\(^1\\)H-\\(^{31}\\)P HETCOR example. To use such data in SpinPlots, you need to export the 2D <code>spectrum</code> and the model <code>fit</code> in DMFit as <code>.ppm</code> files.</p> <pre><code># Read a 2D 1H-31P HETCOR spectrum and fit\nhector = read_nmr(\n    ['../../data/DMFit/hetcor_spectrum.ppm', \n     '../../data/DMFit/hetcor_model.ppm'],\n    provider=\"dmfit\",\n    tags=[\"spectrum\", \"fit\"],   \n)\n\nhector.plot(\n    contour_start=10,\n    contour_num=25,\n    contour_factor=1.5,\n    colors=['black', 'red'],\n    xlim=(38, 24),\n    ylim=(22, 16),\n    xaxislabel=\"$^{31}$P $\\delta$ / ppm\",\n    yaxislabel=\"$^{1}$H $\\delta$ / ppm\",\n)\n</code></pre>"},{"location":"user_guide/dmfit_plots.html#plotting-1d-fits","title":"Plotting 1D fits","text":""},{"location":"user_guide/dmfit_plots.html#plot-2d-fits","title":"Plot 2D Fits","text":""},{"location":"user_guide/easy_plots.html","title":"NMR plots made easy","text":"<p>The current version of <code>SpinPlots</code> only works with processed Bruker data. If you\u2019re dealing with unprocessed data or using data from a different brand, we recommend using NMRglue instead. Also, if you want more control over the looks of your plot, <code>SpinPlots</code> might feel a bit limited since it mostly sticks to the default matplotlib style for now.</p> <p>For this tutorial a series of <sup>13</sup>C,<sup>15</sup>N-labelled Tyrosine and <sup>13</sup>C,<sup>15</sup>N labelled Glycine spectra are used to show the implementation of <code>SpinPlots</code>.</p> <pre><code>from __future__ import annotations\nimport warnings\nwarnings.filterwarnings(\"ignore\", category=UserWarning)\n\nfrom spinplots.io import read_nmr\n</code></pre> <p>Here is how to load and plot a simple 1D spectrum of Tyrosine acquired at 9.4T using a MAS rate of 10kHz</p> <pre><code>tyr = read_nmr(\"../../data/1D/tyrosine/pdata/1\")\ntyr.plot(xlim=(200, -10))\n</code></pre> <p><code>SpinPlots</code> uses Matplotlib's standard style by default. If you want to customize the appearance of your spectra, you can use the option <code>return_fig=True</code>. This allows you to return the figure object and modify it as needed before displaying or saving it.</p> <p>The <code>plot</code> function has a bunch of useful features beyond just making a simple plot. Some of the key ones include:</p> <ul> <li>Plotting several plots together</li> <li>Plot with/without frame</li> <li>Labelling of spectra</li> <li>Normalization of data</li> <li>Select colors for each spectrum using matplotlib's colors</li> <li>Saving the plot directly to a file</li> </ul> <p>The following examples includes all options currently available in the <code>plot</code> for 1D data function.</p> <pre><code>tyr.plot(\n    labels=[\"Tyrosine\"],  # Set the labels for the spectra\n    color=[\"black\"],  # Set the colors for the spectra\n    xlim=(200, 0),  # Set the x-axis limits\n    alpha=1,  # Set the transparency of the lines (1 for no transparency, 0 for transparent)\n    linewidth=2,  # Set the line width\n    linestyle=\"-\",  # Set the line style (styles, e.g. '--', ':', '-.', etc.)\n    axisfont=\"Arial\",  # Set the font style of the axis labels\n    axisfontsize=12,  # Set the font size of the axis labels\n    tickfont=\"Arial\",  # Set the font style of the tick labels\n    tickfontsize=10,  # Set the font size of the tick labels\n    tickspacing=20,  # Set the spacing between the ticks on X-axis\n    frame=True,  # Set True or False to add or remove frame\n    save=False,  # Set True or False to save the figure\n    filename=\"../../data/1D/tyrosine_13C\",  # Set the path and filename for saving the figure\n    format=\"svg\",\n)  # Set the format of the saved figure (e.g. 'png', 'pdf', 'svg', etc.)\n</code></pre> <p><code>plot</code> sets the Y-axis and X-axis labels automatically based on the data loaded.</p> <p>The Y-axis and X-axis labels can be edited with the <code>yaxislabel</code> and <code>xaxislabel</code> options, as follows :</p> <pre><code>tyr.plot(\n    labels=[\"Tyrosine\"],\n    color=[\"black\"],\n    xlim=(200, 0),\n    xaxislabel=\"my label 1\",  # Set the label for the x-axis\n    yaxislabel=\"my label 2\",  # Set the label for the y-axis\n    frame=True,\n    save=False,\n    filename=\"../../data/1D/tyrosine_13C\",\n    format=\"svg\",\n)\n</code></pre> <p>For multiple spectra, the <code>plot</code> function supports normalization of data and plot stacking. For this example two <sup>13</sup>C NMR datasets of Tyrosine and Glycine are used with different number of scans.</p> <pre><code># Use a list of path to read multiple spectra\nbase_path = \"../../data/1D/\"\ngly_tyr = read_nmr([base_path + \"glycine/pdata/1\", base_path + \"tyrosine/pdata/1\"])\ngly_tyr.plot(\n    labels=[\"Glycine\", \"Tyrosine\"],\n    color=[\"orange\", \"blue\"],\n    xlim=(200, 0),\n    alpha=1,\n    linewidth=1,\n    linestyle=\"-\",\n    axisfont=\"Arial\",\n    axisfontsize=12,\n    tickfont=\"Arial\",\n    tickfontsize=10,\n    tickspacing=20,\n    frame=True,\n    save=True,\n    filename=\"../../data/1D/overlapped\",\n    format=\"svg\",\n)\n</code></pre> <p>The spectrum can be normalized using the <code>normalize</code> using either <code>max</code> or <code>scans</code> to normalize by the maximum number of the number of scans.</p> <pre><code>gly_tyr.plot(\n    labels=[\"Glycine\", \"Tyrosine\"],\n    color=[\"orange\", \"blue\"],\n    xlim=(200, 0),\n    alpha=1,\n    linewidth=1,\n    linestyle=\"-\",\n    axisfont=\"Arial\",\n    axisfontsize=12,\n    tickfont=\"Arial\",\n    tickfontsize=10,\n    tickspacing=20,\n    normalize=\"max\",  # Normalized by maximum point\n    frame=True,\n    save=False,\n    filename=\"../../data/1D/overlapped\",\n    format=\"svg\",\n)\n</code></pre> <p>Multiple spectra can be plotted using the <code>stacked</code> option, as follows :</p> <pre><code>gly_tyr.plot(\n    labels=[\"Glycine\", \"Tyrosine\"],\n    color=[\"orange\", \"blue\"],\n    xlim=(200, 0),\n    alpha=1,\n    linewidth=1,\n    linestyle=\"-\",\n    axisfont=\"Arial\",\n    axisfontsize=12,\n    tickfont=\"Arial\",\n    tickfontsize=10,\n    tickspacing=20,\n    normalize=\"max\",\n    stacked=True,  # Set to True to stack the spectra\n    frame=True,\n    save=False,\n    filename=\"../../data/1D/stacked\",\n    format=\"svg\",\n)\n</code></pre> <p>or with more plots</p> <pre><code>base_path = \"../../data/1D/\"\ngly_tyr_ala_arg = read_nmr(\n    [\n        base_path + \"glycine/pdata/1\",\n        base_path + \"tyrosine/pdata/1\",\n        base_path + \"alanine/pdata/1\",\n        base_path + \"arginine/pdata/1\",\n    ]\n)\ngly_tyr_ala_arg.plot(\n    labels=[\"Glycine\", \"Tyrosine\", \"Alanine\", \"Arginine\"],\n    color=[\n        \"#03045e\",\n        \"#023e8a\",\n        \"#0077b6\",\n        \"#0096c7\",\n    ],  # Hex color codes is also supported\n    xlim=(200, 0),\n    alpha=1,\n    linewidth=1,\n    linestyle=\"-\",\n    axisfont=\"Arial\",\n    axisfontsize=12,\n    tickfont=\"Arial\",\n    tickfontsize=10,\n    tickspacing=20,\n    normalize=\"max\",\n    stacked=True,  # Set to True to stack the spectra\n    frame=True,\n    save=False,\n    filename=\"../../data/1D/stacked\",\n    format=\"svg\",\n)\n</code></pre> <p>The <code>plot</code> allows the presentation of multiple spectra in a grid style (subplots), by using the option <code>grid='rows x columns</code>.</p> <pre><code>gly_tyr.plot(\n    grid=\"1x2\",  # Set the grid layout '1x2' for 1 row and 2 columns\n    labels=[\"Glycine\", \"Tyrosine\"],\n    color=[\"orange\", \"blue\"],\n    xlim=(200, 0),\n    frame=True,\n    save=False,\n    normalize=\"max\",\n    filename=\"../../data/1D/grid\",\n    format=\"svg\",\n)\n</code></pre> <p>More complex grid spaces can be created, as follows :</p> <pre><code>gly_tyr_ala_arg.plot(\n    grid=\"2x2\",  # Set the grid layout '2x2' for 2 rows and 2 columns\n    labels=[\"Glycine\", \"Tyrosine\", \"Alanine\", \"Arginine\"],\n    color=[\n        \"#03045e\",\n        \"#023e8a\",\n        \"#0077b6\",\n        \"#0096c7\",\n    ],  # Hex color codes is also supported\n    xlim=(200, 0),\n    normalize=True,\n    frame=True,\n    save=False,\n    filename=\"../../data/1D/grid\",\n    format=\"svg\",\n)\n</code></pre> <p>Lastly, the <code>plot</code> function makes it super easy to plot 2D NMR spectra. You just need to provide a bit more info to customize the plot. Here\u2019s what you can specify:</p> <ul> <li><code>countour_start</code>: the minimum value for the contour plot</li> <li><code>countour_num</code>: how many contour levels you want</li> <li><code>countour_factor</code>: the factor between each contour level</li> <li><code>cmap</code>: the matplotlib colormap for countour (default is 'black')</li> <li><code>colors</code>: can be used instead of <code>cmap</code> with values such as <code>blue</code>, <code>red</code>, etc.</li> <li><code>xlim</code>: limits for the x-axis, i.e. direct dimension (F2)</li> <li><code>ylim</code>: limits for the y-axis, i.e. indirect dimension (F1)</li> <li><code>save</code>: whether you want to save the plot</li> <li><code>filename</code>: the name to save the plot as</li> <li><code>format</code>: the file format to save it</li> </ul> <p>The following example includes all options currently available in the <code>bruker2d</code> function.</p> <p>A simple heteronuclear {<sup>1</sup>H}-<sup>13</sup>C 2D acquired at 9.4T using a MAS rate of 10kHz can be plotted, as follows :</p> <pre><code>data_het = read_nmr(\"../../data/2D/43/pdata/1\")\ndata_het.plot(\n    contour_start=4e10,  # Set the starting value for the contour lines\n    contour_num=12,  # Set the number of contour lines\n    contour_factor=1.5,  # Set the factor for the contour lines\n    cmap=\"viridis\",  # Set the colormap for the contour plot. Available colormaps: https://matplotlib.org/stable/users/explain/colors/colormaps.html\n    xlim=(180, 30),  # Set the x-axis limits\n    ylim=(14, -2),  # Set the y-axis limits\n    linewidth_contour=1,  # Set the line width for the contour lines\n    linewidth_proj=1.5,  # Set the line width for the projection lines\n    axisfont=\"Arial\",  # Set the font style of the axis labels\n    axisfontsize=12,  # Set the font size of the axis labels\n    tickfont=\"Arial\",  # Set the font style of the tick labels\n    tickfontsize=10,  # Set the font size of the tick labels\n    tickspacing=20,  # Set the spacing between the ticks on X-axis\n    save=False,  # Set True or False to save the figure\n    filename=\"../../data/2D/2d_hetero\",  # Set the path and filename for saving the figure\n    format=\"png\", # Set the format of the saved figure (e.g. 'png', 'pdf', 'svg', etc.)\n)\n</code></pre> <p>Some NMR spectra, like double-quantum (DQ) experiments, are often visualized with a diagonal line representing <code>y=2x</code>. You can add this diagonal line for any line of the form <code>y=nx</code> using the keyword <code>diag=n</code>, where <code>n</code> sets the desired quantum order. The following example shows a <sup>13</sup>C-<sup>13</sup>C DQ-SQ experiment. The option <code>homo=True</code> is only needed if the y-axis label isn\u2019t displaying correctly, such as when the DQ-SQ is acquired through CPMAS.</p> <p>Similarly, a simple homonuclear <sup>13</sup>C-<sup>13</sup>C 2D can be plotted, as follows :</p> <pre><code>data_homo = read_nmr(\"../../data/2D/16/pdata/1\")\ndata_homo.plot(\n    contour_start=1e7,\n    contour_num=25,\n    contour_factor=1.5,\n    cmap=\"viridis\",\n    xlim=(200, 30),\n    ylim=(400, 60),\n    linewidth_contour=1,\n    linewidth_proj=1.5,\n    axisfont=\"Arial\",\n    axisfontsize=12,\n    tickfont=\"Arial\",\n    tickfontsize=10,\n    tickspacing=20,\n    homo=True,  # Set to true if spectra is a homonuclear correlation\n    diag=2,  # Set the diagonal splot 2 for DQ y=2x\n    save=False,\n    filename=\"../../data/2D/2d_homo\",\n    format=\"png\",\n)\n</code></pre> <p><code>bruker2d</code> function sets the Y-axis and X-axis labels automatically based on the data loaded, but you can edit them with the <code>yaxislabel</code> and <code>xaxislabel</code> options, as follows :</p> <pre><code>data_homo.plot(\n    contour_start=1e7,\n    contour_num=25,\n    contour_factor=1.5,\n    cmap=\"viridis\",\n    xlim=(200, 30),\n    ylim=(400, 60),\n    linewidth_contour=1,\n    linewidth_proj=1.5,\n    axisfont=\"Arial\",\n    axisfontsize=12,\n    tickfont=\"Arial\",\n    tickfontsize=10,\n    tickspacing=20,\n    homo=True,\n    diag=2,\n    xaxislabel=\"SQ $^{13}$C (ppm)\",  # Set the label for the X-axis\n    yaxislabel=\"DQ $^{13}$C (ppm)\",  # Set the label for the Y-axis\n    save=False,\n    filename=\"../../data/2D/2d_homo\",\n    format=\"png\",\n)\n</code></pre>"},{"location":"user_guide/easy_plots.html#plot-1d-spectra","title":"Plot 1D spectra","text":""},{"location":"user_guide/easy_plots.html#costumization-of-1d-spectra","title":"Costumization of 1D spectra","text":""},{"location":"user_guide/easy_plots.html#normalization","title":"Normalization","text":""},{"location":"user_guide/easy_plots.html#stacking","title":"Stacking","text":""},{"location":"user_guide/easy_plots.html#grid","title":"Grid","text":""},{"location":"user_guide/easy_plots.html#plot-2d-spectra","title":"Plot 2D spectra","text":""},{"location":"user_guide/easy_plots.html#heteronuclear-correlation","title":"Heteronuclear correlation","text":""},{"location":"user_guide/easy_plots.html#homonuclear-correlation","title":"Homonuclear correlation","text":""},{"location":"user_guide/read_export.html","title":"Costumize and Export","text":"<p>The functions in the previous tutorial make plotting pretty automatic, using matplotlib's standard style. But sometimes, you might just want to read the data without immediately plotting it\u2014maybe to style it your own way or to convert it into a different format.</p> <pre><code>from __future__ import annotations\nimport warnings\nwarnings.filterwarnings(\"ignore\", category=UserWarning)\n\nimport matplotlib.pyplot as plt\n\nfrom spinplots.io import read_nmr\nfrom spinplots.utils import nmr_df\n</code></pre> <p>In the previous tutorial, we used <code>bruker1d(['../../data/1D/glycine/pdata/1'], xlim=(250, -20))</code> to create a simple <sup>13</sup>C NMR plot. By adding the option <code>return_fig=True</code>, you can return the figure object, which allows you to further customize the appearance of the spectrum as you like.</p> <pre><code>gly = read_nmr(\"../../data/1D/glycine/pdata/1\")\nfig, ax = gly.plot(xlim=(250, -20), return_fig=True)\nax.set_title(\"Customized plot\")\nax.set_xlabel(\"13-Carbon NMR in ppm\")\nax.lines[0].set_color(\"purple\")\nax.lines[0].set_linewidth(2)\nax.lines[0].set_linestyle(\"-.\")\nfig.savefig(\"../../data/1D/customized_plot.png\")\n</code></pre> <p>A different option is to use the <code>nmr_df</code> function from <code>spinplots.utils</code> to get a Pandas DataFrame. This way, you can manipulate the data however you like before plotting.</p> <pre><code>df_nmr = nmr_df(\"../../data/1D/glycine/pdata/1\")\ndf_nmr\n</code></pre> hz ppm intensity norm_intensity nuclei 0 62320.002580 619.310059 36928800.0 0.004269 13C 1 62318.476701 619.294895 40210336.0 0.004648 13C 2 62316.950822 619.279732 39049024.0 0.004514 13C 3 62315.424943 619.264568 33449568.0 0.003867 13C 4 62313.899064 619.249404 23894656.0 0.002762 13C ... ... ... ... ... ... 65531 -37672.368025 -374.372200 -20542656.0 -0.002375 13C 65532 -37673.893904 -374.387363 -8086976.0 -0.000935 13C 65533 -37675.419783 -374.402527 5093344.0 0.000589 13C 65534 -37676.945662 -374.417690 17696256.0 0.002046 13C 65535 -37678.471541 -374.432854 28418208.0 0.003285 13C <p>65536 rows \u00d7 5 columns</p> <pre><code>plt.plot(df_nmr[\"ppm\"], df_nmr[\"intensity\"], color=\"green\")\nplt.xlim(250, -20)\nplt.xlabel(\"$^{31}$C (ppm)\")\nplt.ylabel(\"Intensity (a.u.)\")\nplt.show()\n</code></pre> <p>Pandas DataFrames can be easily exported to other formats such as <code>.csv</code>. You can do this directly in your code with <code>df.to_csv('exported_data.csv')</code>, or use the <code>bruker2csv</code> function from the terminal for a quick export.</p> <pre><code>bruker2csv ../../data/1D/glycine/pdata/1 ../../data/1D/exported_data.csv\n</code></pre>"},{"location":"user_guide/read_export.html#read-and-export-data","title":"Read and Export data","text":""},{"location":"user_guide/read_export.html#customize-spinplots","title":"Customize spinplots","text":""},{"location":"user_guide/read_export.html#export-data-to-pandas-and-csv","title":"Export data to Pandas and CSV","text":""},{"location":"user_guide/read_export.html#convert-data-in-the-terminal","title":"Convert data in the terminal","text":""},{"location":"user_guide/spin_objects.html","title":"The Spin object","text":"<pre><code>import warnings\nwarnings.filterwarnings(\"ignore\", category=UserWarning)\n\nfrom spinplots.io import read_nmr\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport pandas as pd\n</code></pre> <pre><code># 1D data\nglycine = read_nmr(\"../../data/1D/glycine/pdata/1\", provider=\"bruker\")\n\nprint(f\"Object type: {type(glycine).__name__}\")\nprint(f\"Dimensions: {glycine.ndim}D\")\nprint(f\"Provider: {glycine.provider}\")\nprint(f\"Path to file: {glycine.spectrum['path']}\")\n\nprint(\"\\nAvailable keys\")\nfor key in glycine.spectrum.keys():\n    print(f\"- {key}\")\n</code></pre> <pre>\n<code>Object type: Spin\nDimensions: 1D\nProvider: bruker\nPath to file: ../../data/1D/glycine/pdata/1\n\nAvailable keys\n- path\n- metadata\n- ndim\n- data\n- norm_max\n- norm_scans\n- projections\n- ppm_scale\n- hz_scale\n- nuclei\n</code>\n</pre> <pre><code># Load a 2D spectrum\nspectrum_2d = read_nmr(\"../../data/2D/16/pdata/1\", provider=\"bruker\")\n\nprint(f\"Type: {type(spectrum_2d).__name__}\")\nprint(f\"Dimensions: {spectrum_2d.ndim}D\")\nprint(f\"Provider: {spectrum_2d.provider}\")\nprint(f\"Path to file: {spectrum_2d.spectrum['path']}\")\n\nprint(\"\\nAvailable keys\")\nfor key in spectrum_2d.spectrum.keys():\n    print(f\"- {key}\")\n</code></pre> <pre>\n<code>Type: Spin\nDimensions: 2D\nProvider: bruker\nPath to file: ../../data/2D/16/pdata/1\n\nAvailable keys\n- path\n- metadata\n- ndim\n- data\n- norm_max\n- norm_scans\n- projections\n- ppm_scale\n- hz_scale\n- nuclei\n</code>\n</pre> <pre><code># Load multiple spectra into a collection\ncollection = read_nmr(\n    [\"../../data/1D/glycine/pdata/1\", \"../../data/1D/alanine/pdata/1\"], \n    provider=\"bruker\",\n    tags=[\"Glycine\", \"Alanine\"]  # Optional custom tags\n)\n\nprint(f\"Type: {type(collection).__name__}\")\nprint(f\"Dimensions: {collection.ndim}D\")\nprint(f\"Provider: {collection.provider}\")\nprint(f\"Path to file 1: {collection[0].spectrum['path']}\")\nprint(f\"Path to file 2: {collection[1].spectrum['path']}\")\n\nprint(\"\\nKeys file 1\")\nfor key in collection[0].spectrum.keys():\n    print(f\"- {key}\")\n\nprint(\"\\nKeys file 2\")\nfor key in collection[1].spectrum.keys():\n    print(f\"- {key}\")\n</code></pre> <pre>\n<code>Type: SpinCollection\n</code>\n</pre> <pre>\n---------------------------------------------------------------------------\nAttributeError                            Traceback (most recent call last)\nCell In[4], line 9\n      2 collection = read_nmr(\n      3     [\"../../data/1D/glycine/pdata/1\", \"../../data/1D/alanine/pdata/1\"], \n      4     provider=\"bruker\",\n      5     tags=[\"Glycine\", \"Alanine\"]  # Optional custom tags\n      6 )\n      8 print(f\"Type: {type(collection).__name__}\")\n----&gt; 9 print(f\"Dimensions: {collection.ndim}D\")\n     10 print(f\"Provider: {collection.provider}\")\n     11 print(f\"Path to file 1: {collection[0].spectrum['path']}\")\n\nAttributeError: 'SpinCollection' object has no attribute 'ndim'</pre> <pre><code>collection = read_nmr(\n    [\"../../data/1D/glycine/pdata/1\", \"../../data/1D/alanine/pdata/1\"], \n    provider=\"bruker\",\n    tags=[\"Glycine\", \"Alanine\"]  # Add custom tag\n)\n\nglycine_spin = collection[\"Glycine\"]\nalanine_spin = collection[\"Alanine\"]\n\nprint(f\"Glycine Spin object: {glycine_spin}\")\nprint(f\"Alanine Spin object: {alanine_spin}\")\n\n# Can also be accessed by index\nfirst_spin = collection[0]\nprint(f\"\\nFirst Spin in collection: {first_spin}\")\n\n# Get all tags\nall_tags = list(collection.spins.keys())\nprint(f\"\\nAvailable spectra: {all_tags}\")\n</code></pre> <pre>\n<code>Glycine Spin object: Spin(tag=Glycine, ndim=1, provider='bruker', path=../../data/1D/glycine/pdata/1)\nAlanine Spin object: Spin(tag=Alanine, ndim=1, provider='bruker', path=../../data/1D/alanine/pdata/1)\n\nFirst Spin in collection: Spin(tag=Glycine, ndim=1, provider='bruker', path=../../data/1D/glycine/pdata/1)\n\nAvailable spectra: ['Glycine', 'Alanine']\n</code>\n</pre> <p><code>Spin</code> objects can be easily added or romoved from a <code>SpinCollection</code> with:</p> <pre><code>tyrosine = read_nmr(\"../../data/1D/tyrosine/pdata/1\", provider=\"bruker\")\ntyrosine.tag = \"Tyrosine\"\ncollection.append(tyrosine)\n\nprint(f\"Collection sized after adding: {collection.size}\")\nprint(f\"Updated tags: {list(collection.spins.keys())}\\n\")\n\ncollection.remove(\"Alanine\")\nprint(f\"Collection size after removal: {collection.size}\")\nprint(f\"Remaining tags: {list(collection.spins.keys())}\")\n</code></pre> <pre>\n<code>Collection sized after adding: 3\nUpdated tags: ['Glycine', 'Alanine', 'Tyrosine']\n\nCollection size after removal: 2\nRemaining tags: ['Glycine', 'Tyrosine']\n</code>\n</pre> <pre><code>fig, ax = plt.subplots(figsize=(6, 5))\n\n# Load glycine spectrum\nglycine = read_nmr(\"../../data/1D/glycine/pdata/1\", provider=\"bruker\")\nppm = glycine.spectrum[\"ppm_scale\"]\ndata = glycine.spectrum[\"data\"]\nnuclei = glycine.spectrum[\"nuclei\"]\n\n# Extract the number and nucleus from the nuclei string\nnumber = \"\".join(filter(str.isdigit, nuclei))\nnucleus = \"\".join(filter(str.isalpha, nuclei))\n\nax.plot(ppm, data, linewidth=1.5, color='darkblue')\nax.set_xlabel(f\"$^{{{number}}}${nucleus} (ppm)\", fontsize=14)\nax.set_ylabel(\"Intensity (a.u.)\", fontsize=14)\nax.set_xlim(180, 0)\nplt.tight_layout()\nplt.show()\n</code></pre> <p>You can also use all the data in <code>SpinCollection</code> objects to plot the data as you wish</p> <pre><code>collection = read_nmr(\n    [\"../../data/1D/glycine/pdata/1\", \"../../data/1D/alanine/pdata/1\"], \n    provider=\"bruker\",\n    tags=[\"Glycine\", \"Alanine\"]  # Add custom tag\n)\n\nfig, ax = plt.subplots(figsize=(6, 5))\n\ncolors = ['#1f77b4', '#ff7f0e']\n\nfor i, (tag, spin) in enumerate(collection):\n    ppm = spin.spectrum[\"ppm_scale\"]\n    data = spin.spectrum[\"norm_max\"]  # Use normalized data by maximum intensity\n    color = colors[i % len(colors)]\n\n    ax.plot(ppm, data, linewidth=1.5, label=tag, color=color)\n\nax.set_xlabel(\"$^{13}$C (ppm)\", fontsize=12)\nax.set_ylabel(\"Normalized Intensity\", fontsize=12)\nax.set_xlim(180, 0)\nax.grid(alpha=0.3, linestyle='--')\nplt.tight_layout()\nplt.show()\n</code></pre> <p><code>Spin</code> and <code>SpinCollection</code> objects from 2D spectra can also be used to plot the spectra, with or without projections.</p> <pre><code>fig = plt.figure(figsize=(8, 6))\ngs = fig.add_gridspec(2, 2,\n                      width_ratios=[0.8, 6],\n                      height_ratios=[0.8, 6],\n                      wspace=0.05, hspace=0.05)\n\nax_main = fig.add_subplot(gs[1, 1])  # Main 2D spectrum\nax_top = fig.add_subplot(gs[0, 1], sharex=ax_main)  # Top projection (F2)\nax_left = fig.add_subplot(gs[1, 0], sharey=ax_main)  # Left projection (F1)\n\nspectrum_2d = read_nmr(\"../../data/2D/16/pdata/1\", provider=\"bruker\")\ndata_2d = spectrum_2d.spectrum[\"data\"]\nppm_f1 = spectrum_2d.spectrum[\"ppm_scale\"][0]\nppm_f2 = spectrum_2d.spectrum[\"ppm_scale\"][1]\nproj_f1 = spectrum_2d.spectrum[\"projections\"][\"f1\"]['F1 projection']\nproj_f2 = spectrum_2d.spectrum[\"projections\"][\"f2\"]['F2 projection']\n\ncontour_start = 6e6\ncontour_factor = 1.5\ncontour_num = 25\ncontour_levels = contour_start * contour_factor ** np.arange(contour_num)\n\nX, Y = np.meshgrid(ppm_f2, ppm_f1)\ncontour = ax_main.contour(\n    X, Y, data_2d, \n    levels=contour_levels,\n    colors='black',\n    linewidths=0.5\n)\n\nax_top.plot(ppm_f2, proj_f2, 'k-', linewidth=1)\nax_left.plot(-proj_f1, ppm_f1, 'k-', linewidth=1)\nax_top.axis('off')\nax_left.axis('off')\nax_main.yaxis.tick_right()\nax_main.yaxis.set_label_position(\"right\")\nax_main.set_xlim(200, 30)\nax_main.set_ylim(400, 60)\nax_left.set_ylim(400, 60)\nax_top.set_xlim(200, 30)\n\nnuclei = spectrum_2d.spectrum[\"nuclei\"]\nnumber_f1, nucleus_f1 = \"\".join(filter(str.isdigit, nuclei[0])), \"\".join(filter(str.isalpha, nuclei[0]))\nnumber_f2, nucleus_f2 = \"\".join(filter(str.isdigit, nuclei[1])), \"\".join(filter(str.isalpha, nuclei[1]))\n\nax_main.set_xlabel(f\"$^{{{number_f2}}}${nucleus_f2} (ppm)\", fontsize=14)\nax_main.set_ylabel(f\"$^{{{number_f2}}}${nucleus_f2} (ppm)\", fontsize=14)\n</code></pre> <pre>\n<code>Text(0, 0.5, '$^{13}$C (ppm)')</code>\n</pre> <pre><code>from scipy.signal import find_peaks\n\nalanine = collection[\"Alanine\"]\n\nppm = alanine.spectrum[\"ppm_scale\"]\ndata = alanine.spectrum[\"norm_max\"]\n\n# Find peaks\npeaks, _ = find_peaks(data, height=0.1, distance=50)\npeak_ppm = ppm[peaks]\npeak_heights = data[peaks]\n\nfig, ax = plt.subplots(figsize=(7, 6))\nax.plot(ppm, data, 'b-', linewidth=1.5)\nax.plot(peak_ppm, peak_heights, 'ro', label='Detected Peaks')\n\nfor i, (x, y) in enumerate(zip(peak_ppm, peak_heights)):\n    ax.annotate(f'{x:.1f}', xy=(x, y), xytext=(0, 10), \n                textcoords='offset points', ha='center', fontsize=10)\n\nax.set_xlabel('$^{13}$C (ppm)', fontsize=14)\nax.set_ylabel('Normalized Intensity', fontsize=14)\nax.legend()\nax.spines['top'].set_visible(False)\nax.spines['right'].set_visible(False)\n\nplt.tight_layout()\nplt.show()\n</code></pre>"},{"location":"user_guide/spin_objects.html#working-with-spin-objects-directly","title":"Working with Spin objects directly","text":"<p><code>SpinPlots</code> makes it easy to create plots with a few lines of code using the <code>.plot()</code> method, advanced users might want more control over data visualization. This tutorial will show you how to work directly with <code>Spin</code> and <code>SpinCollection</code> objects to access raw data, process it, and create custom plots.</p>"},{"location":"user_guide/spin_objects.html#spin-and-spincollection-objects","title":"Spin and SpinCollection objects","text":"<p>SpinPlots provides two main classes for handling NMR data:</p> <ol> <li><code>Spin</code>: Represents a single NMR dataset</li> <li><code>SpinCollection</code>: Is a collection of <code>Spin</code> objects</li> </ol>"},{"location":"user_guide/spin_objects.html#working-with-spin-objects","title":"Working with Spin objects","text":""},{"location":"user_guide/spin_objects.html#working-with-spincollection","title":"Working with SpinCollection","text":"<p>A <code>SpinCollection</code> behaves like a dictionary of <code>Spin</code> objects, where each spectrum can be accessed by its tag:</p>"},{"location":"user_guide/spin_objects.html#create-plots-from-spin-objects","title":"Create plots from Spin objects","text":"<p>The <code>Spin</code> object contains all information necessary to make a NMR plot</p>"},{"location":"user_guide/spin_objects.html#find-peaks","title":"Find peaks","text":""}]}