var __index = {"config":{"lang":["en"],"separator":"[\\s\\-,:!=\\[\\]()\"`/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"SpinPlots","text":"<p>Welcome to the documentation for <code>SpinPlots</code>! This Python package is designed to simplify the process of reading and plotting NMR data. While NMRglue is a powerful library for reading, processing, and analyzing NMR data, creating basic plots often requires a lot of code. <code>SpinPlots</code> streamlines these tasks, allowing you to produce clean, publication-ready plots with minimal effort.</p> <p>For example, to generate a simple 1D NMR plot using NMRglue, you would typically write the following:</p> <pre><code># Import python libraries\nimport nmrglue as ng\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# Read Bruker's processed data\ndic, data = ng.bruker.read_pdata(\"Data/1/pdata/1/\")\n\n# Get universal dic\nudic = ng.bruker.guess_udic(dic, data)\n\n# Create a unit conversion object for the axis\nuc = ng.fileiobase.uc_from_udic(udic)\n\n# Get ppm scale\nppm_scale = uc.ppm_scale()\n\n# Plot the spectrum\nplt.plot(ppm_scale, data, label=\"Sample X\")\nplt.xlim(20, 0)\nplt.xlabel(\"$^1$H (ppm)\")\nplt.ylabel(\"Intensity (a.u.)\")\nplt.legend()\n\n# Save the figure\nfig.savefig(\"spectrum.png\")\n</code></pre> <p>This is a lot of code for a simple 1D plot! If one wants to make a 2D plot with projections things become even harder</p> <p><code>SpinPlots</code> tries to simplify the process. With just one function call, you can create the same 1D plot:</p> <pre><code>from spinplots.plot import bruker1d\n\nbruker1d(\n    [\"Data/1/pdata/1/\"],\n    labels=[\"Sample X\"],\n    xlim=(20, 0),\n    save=True,\n    filename=\"spectrum\",\n    format=\"png\",\n)\n</code></pre>"},{"location":"about/changelog.html","title":"Changelog","text":"<p>All notable changes to this project will be documented in this file.</p> <p>The format is based on Keep a Changelog, and this project adheres to Semantic Versioning.</p>"},{"location":"about/changelog.html#010","title":"[0.1.0]","text":""},{"location":"about/changelog.html#added","title":"Added","text":"<ul> <li>Terminal functionality: Added <code>bruker2csv</code> to convert NMR data into CSV from the terminal.</li> <li>Plotting functions: Added the following functions to streamline plotting:<ul> <li><code>bruker1d</code> for generating 1D NMR plots</li> <li><code>bruker1d_grid</code> for generating subplots</li> <li><code>bruker2d</code> for generating 2D NMR plots</li> </ul> </li> <li>NMR dataframe: Added the <code>nmr_df</code> function to create a Pandas DataFrame from NMR data, for further data manipulation, analysis and plotting.</li> <li>Tutorials:<ul> <li>Creating 1D and 2D plots using the spinplots functions.</li> <li>Obtain a Pandas DataFrame from NMR data for custom plot styling and manipulation.</li> </ul> </li> </ul>"},{"location":"about/changelog.html#001","title":"[0.0.1]","text":""},{"location":"about/changelog.html#added_1","title":"Added","text":"<ul> <li>The initial release!</li> </ul>"},{"location":"about/contributors.html","title":"People","text":"<p>SpinPlots was originally written and is actively maintained by Carlos Bornes, Daniel Pereira and M\u00e1rcio Soares</p>"},{"location":"about/contributors.html#contributorscontributions","title":"Contributors/Contributions","text":"<p>Additional contributions were made by the individuals listed here.</p>"},{"location":"about/contributors.html#inspiration","title":"Inspiration","text":"<p>Some project that served as inspiration for SpinPlots are:</p> <ul> <li> <p>Quantum Accelerators Python package template created by Andrew S. Rosen</p> </li> <li> <p>NMRglue by Jonathan J. Helmus for providing Python function for reading, processing NMR data</p> </li> <li> <p>Our own frustration trying to remember NMRglue's syntax and using Bruker's TopSpin for producing plots for papers. \ud83e\udd2a</p> </li> </ul>"},{"location":"about/license.html","title":"License","text":"LICENSE.md<pre><code>MIT License\n\nCopyright (c) 2024\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n</code></pre>"},{"location":"installation/install.html","title":"Installation","text":"<p>If you have Python and pip installed, you can easily install Spinplots with the following command:</p> <pre><code>pip install git+https://github.com/nuts-org/spinplots\n</code></pre> <p>All dependecies <code>pyproject.toml</code> file are installed automatically.</p> <p>To verify that the package has been installed successfully, open a Python console and run:</p> <pre><code>import spinplots\n</code></pre>"},{"location":"reference/SUMMARY.html","title":"SUMMARY","text":"<ul> <li>spinplots<ul> <li>cli</li> <li>plot</li> <li>utils</li> </ul> </li> </ul>"},{"location":"reference/spinplots/cli.html","title":"cli","text":""},{"location":"reference/spinplots/cli.html#spinplots.cli.main","title":"main","text":"<pre><code>main()\n</code></pre> <p>Convert Bruker's NMR data to csv files on the terminal</p> Source code in <code>spinplots/cli.py</code> <pre><code>def main():\n    \"\"\"\n    Convert Bruker's NMR data to csv files on the terminal\n    \"\"\"\n    if len(sys.argv) != 3:\n        logging.error(\"Incorrect number of arguments provided.\")\n        logging.error(\"Usage: bruker2csv &lt;path_to_data&gt; &lt;path_to_output&gt;\")\n\n        sys.exit(1)\n\n    data_path = sys.argv[1]\n    output_path = sys.argv[2]\n\n    try:\n        df_nmr = nmr_df(data_path)\n        if df_nmr.attrs.get(\"nmr_dim\") == 2:\n            df_nmr.to_csv(output_path, index=True)\n            logging.info(f\"Data written to {output_path}\")\n        elif df_nmr.attrs.get(\"nmr_dim\") == 1:\n            df_nmr.to_csv(output_path, index=False)\n            logging.info(f\"Data written to {output_path}\")\n    except Exception as e:\n        logging.error(f\"An error occurred: {e}\")\n        sys.exit(1)\n</code></pre>"},{"location":"reference/spinplots/plot.html","title":"plot","text":""},{"location":"reference/spinplots/plot.html#spinplots.plot.bruker1d","title":"bruker1d","text":"<pre><code>bruker1d(data_paths, labels=None, labelsize=None, xlim=None, save=False, filename=None, format=None, frame=False, normalized=False, stacked=False, color=None, return_fig=False, background_paths=None, background_factors=None, linewidth=None, linestyle=None, alpha=None, yaxislabel=None, xaxislabel=None, axisfontsize=None, axisfont=None, tickfontsize=None, tickfont=None, tickspacing=None)\n</code></pre> <p>Plots 1D NMR spectra from Bruker data.</p> <p>Parameters:     data_paths (str/list): Path or list of paths to the Bruker data directories.</p> <p>Keyword arguments:     labels (list): List of labels for the spectra.     labelsize (float): Font size for the labels.     xlim (tuple): The limits for the x-axis.     save (bool): Whether to save the plot.     filename (str): The name of the file to save the plot.     format (str): The format to save the file in.     frame (bool): Whether to show the frame.     normalized (bool): Whether to normalize the spectra.     stacked (bool): Whether to stack the spectra.     color (str): List of colors for the spectra.     return_fig (bool): Whether to return the figure and axis.     background_paths (list): List of paths to the Bruker background data directories.     background_factors (list): List of factors to multiply the background by.     linewidth (float): Line width of the plot.     linestyle (str): Style of the plot lines.     alpha (float): Transparency of the plot lines.     xaxislabel (str): Label for the axis.     yaxislabel (str): Label for the y-axis.     axisfont (str): Font type for the axis label.     axisfontsize (int): Font size for the axis label.     tickfont (str): Font type for the tick labels.     tickfontsize (int): Font size for the tick labels.     tickspacing (int): Spacing between the tick labels.</p> <p>Example:     bruker1d(['data/1d_data1', 'data/1d_data2'], labels=['Spectrum 1', 'Spectrum 2'], xlim=(0, 100), save=True, filename='1d_spectra', format='png', frame=False, normalized=True, stacked=True, color=['red', 'blue'])</p> Source code in <code>spinplots/plot.py</code> <pre><code>def bruker1d(\n    data_paths,\n    labels=None,\n    labelsize=None,\n    xlim=None,\n    save=False,\n    filename=None,\n    format=None,\n    frame=False,\n    normalized=False,\n    stacked=False,\n    color=None,\n    return_fig=False,\n    background_paths=None,\n    background_factors=None,\n    linewidth=None,\n    linestyle=None,\n    alpha=None,\n    yaxislabel=None,\n    xaxislabel=None,\n    axisfontsize=None,\n    axisfont=None,\n    tickfontsize=None,\n    tickfont=None,\n    tickspacing=None,\n):\n    \"\"\"\n    Plots 1D NMR spectra from Bruker data.\n\n    Parameters:\n        data_paths (str/list): Path or list of paths to the Bruker data directories.\n\n    Keyword arguments:\n        labels (list): List of labels for the spectra.\n        labelsize (float): Font size for the labels.\n        xlim (tuple): The limits for the x-axis.\n        save (bool): Whether to save the plot.\n        filename (str): The name of the file to save the plot.\n        format (str): The format to save the file in.\n        frame (bool): Whether to show the frame.\n        normalized (bool): Whether to normalize the spectra.\n        stacked (bool): Whether to stack the spectra.\n        color (str): List of colors for the spectra.\n        return_fig (bool): Whether to return the figure and axis.\n        background_paths (list): List of paths to the Bruker background data directories.\n        background_factors (list): List of factors to multiply the background by.\n        linewidth (float): Line width of the plot.\n        linestyle (str): Style of the plot lines.\n        alpha (float): Transparency of the plot lines.\n        xaxislabel (str): Label for the axis.\n        yaxislabel (str): Label for the y-axis.\n        axisfont (str): Font type for the axis label.\n        axisfontsize (int): Font size for the axis label.\n        tickfont (str): Font type for the tick labels.\n        tickfontsize (int): Font size for the tick labels.\n        tickspacing (int): Spacing between the tick labels.\n\n    Example:\n        bruker1d(['data/1d_data1', 'data/1d_data2'], labels=['Spectrum 1', 'Spectrum 2'], xlim=(0, 100), save=True, filename='1d_spectra', format='png', frame=False, normalized=True, stacked=True, color=['red', 'blue'])\n    \"\"\"\n    fig, ax = plt.subplots()\n\n    nucleus_set = set()\n\n    # Convert string to list for consistency\n    if isinstance(data_paths, str):\n        data_paths = [data_paths]\n\n    # Default values to be updated if provided\n    defaults = {\n        \"labelsize\": 12,\n        \"linewidth\": 1.0,\n        \"linestyle\": \"-\",\n        \"alpha\": 1.0,\n        \"axisfontsize\": 13,\n        \"axisfont\": None,\n        \"tickfontsize\": 12,\n        \"tickfont\": None,\n        \"yaxislabel\": \"Intensity (a.u.)\",\n        \"xaxislabel\": None,\n        \"tickspacing\": None,\n    }\n\n    params = {k: v for k, v in locals().items() if k in defaults and v is not None}\n    defaults.update(params)\n\n    prev_max = 0\n    for i, data_path in enumerate(data_paths):\n        dic, data = ng.bruker.read_pdata(data_path)\n        udic = ng.bruker.guess_udic(dic, data)\n\n        nuclei = udic[0][\"label\"]\n\n        # Extract the number and nucleus symbol from the label\n        number, nucleus = (\n            \"\".join(filter(str.isdigit, nuclei)),\n            \"\".join(filter(str.isalpha, nuclei)),\n        )\n\n        # Check if the same nucleus is being used\n        nucleus_set.add(nucleus)\n        if len(nucleus_set) &gt; 1:\n            raise ValueError(\"All the spectra must be of the same nucleus.\")\n\n        uc = ng.fileiobase.uc_from_udic(udic, dim=0)\n        ppm = uc.ppm_scale()\n\n        # Normalize the spectrum\n        if normalized == \"max\" or normalized:\n            data = data / np.amax(data)\n        elif normalized == \"scans\":\n            ns = dic[\"acqus\"][\"NS\"]\n            if ns is None:\n                raise ValueError(\"Number of scans not found.\")\n            data = data / ns\n        elif normalized:\n            raise ValueError(\n                \"Invalid value for normalized. Please provide 'max' or 'scans'.\"\n            )\n\n        # Remove background\n        if background_paths is not None:\n            if background_factors is None:\n                raise ValueError(\"Background factors must be provided.\")\n            if i &gt;= len(background_paths):\n                raise ValueError(\n                    \"Number of background paths must be equal to the number of spectra.\"\n                )\n\n            background_path = background_paths[i]\n            background_factor = background_factors[i]\n            dic_bg, data_bg = ng.bruker.read_pdata(background_path)\n            udic_bg = ng.bruker.guess_udic(dic_bg, data_bg)\n\n            uc_bg = ng.fileiobase.uc_from_udic(udic_bg, dim=0)\n            ppm_bg = uc_bg.ppm_scale()\n\n            if ppm.shape != ppm_bg.shape:\n                raise ValueError(\n                    \"Data and background spectra must have the same dimensions.\"\n                )\n\n            # Normalize the background\n            if normalized == \"max\" or normalized:\n                data_bg = data_bg / np.amax(data_bg)\n            elif normalized == \"scans\":\n                ns_bg = dic_bg[\"acqus\"][\"NS\"]\n                if ns_bg is None:\n                    raise ValueError(\"Number of scans not found.\")\n                data_bg = data_bg / ns_bg\n            elif normalized:\n                raise ValueError(\n                    \"Invalid value for normalized. Please provide 'max' or 'scans'.\"\n                )\n\n            # Remove the background\n            data = data - background_factor * data_bg\n\n        # Stack the spectra\n        if stacked:\n            data += i * 1.1 if normalized else prev_max\n\n        # Plot the spectrum\n        if labels and color:\n            ax.plot(\n                ppm,\n                data,\n                label=labels[i],\n                color=color[i],\n                linestyle=defaults[\"linestyle\"],\n                linewidth=defaults[\"linewidth\"],\n                alpha=defaults[\"alpha\"],\n            )\n            ax.legend(\n                bbox_to_anchor=(1.05, 1),\n                loc=\"upper left\",\n                fontsize=defaults[\"labelsize\"],\n                prop={\n                    \"family\": defaults[\"tickfont\"] if defaults[\"tickfont\"] else None,\n                    \"size\": defaults[\"labelsize\"],\n                },\n            )\n        elif labels:\n            ax.plot(\n                ppm,\n                data,\n                label=labels[i],\n                linestyle=defaults[\"linestyle\"],\n                linewidth=defaults[\"linewidth\"],\n                alpha=defaults[\"alpha\"],\n            )\n            ax.legend(\n                bbox_to_anchor=(1.05, 1),\n                loc=\"upper left\",\n                prop={\n                    \"family\": defaults[\"tickfont\"] if defaults[\"tickfont\"] else None,\n                    \"size\": defaults[\"labelsize\"],\n                },\n            )\n        elif color:\n            ax.plot(\n                ppm,\n                data,\n                color=color[i],\n                linestyle=defaults[\"linestyle\"],\n                linewidth=defaults[\"linewidth\"],\n                alpha=defaults[\"alpha\"],\n            )\n        else:\n            ax.plot(\n                ppm,\n                data,\n                linestyle=defaults[\"linestyle\"],\n                linewidth=defaults[\"linewidth\"],\n                alpha=defaults[\"alpha\"],\n            )\n\n        prev_max = np.amax(data)\n\n    # Set axis labels with LaTeX formatting and non-italicized letters\n    if xaxislabel:\n        ax.set_xlabel(\n            xaxislabel,\n            fontsize=defaults[\"axisfontsize\"],\n            fontname=defaults[\"axisfont\"] if defaults[\"axisfont\"] else None,\n        )\n    else:\n        ax.set_xlabel(\n            f\"$^{{{number}}}\\\\mathrm{{{nucleus}}}$ (ppm)\",\n            fontsize=defaults[\"axisfontsize\"],\n            fontname=defaults[\"axisfont\"] if defaults[\"axisfont\"] else None,\n        )\n    ax.tick_params(\n        axis=\"x\",\n        labelsize=defaults[\"tickfontsize\"],\n        labelfontfamily=defaults[\"tickfont\"] if defaults[\"tickfont\"] else None,\n    )\n\n    if defaults[\"tickspacing\"]:\n        ax.xaxis.set_major_locator(plt.MultipleLocator(defaults[\"tickspacing\"]))\n\n    # Remove frame\n    if not frame:\n        ax.spines[\"top\"].set_visible(False)\n        ax.spines[\"right\"].set_visible(False)\n        ax.spines[\"left\"].set_visible(False)\n        ax.set_yticklabels([])\n        ax.set_yticks([])\n    else:\n        ax.set_ylabel(\n            defaults[\"yaxislabel\"],\n            fontsize=defaults[\"axisfontsize\"],\n            fontname=defaults[\"axisfont\"] if defaults[\"axisfont\"] else None,\n        )\n        ax.tick_params(\n            axis=\"y\",\n            labelsize=defaults[\"tickfontsize\"],\n            labelfontfamily=defaults[\"tickfont\"] if defaults[\"tickfont\"] else None,\n        )\n\n    # Set axis limits if provided\n    if xlim:\n        ax.set_xlim(xlim)\n\n    # Show the plot or save it\n    if save:\n        if filename:\n            full_filename = filename + \".\" + format\n        else:\n            full_filename = \"1d_nmr_spectra.\" + format\n        fig.savefig(\n            full_filename, format=format, dpi=300, bbox_inches=\"tight\", pad_inches=0.1\n        )\n    if return_fig:\n        return fig, ax\n    else:\n        plt.show()\n        return None\n</code></pre>"},{"location":"reference/spinplots/plot.html#spinplots.plot.bruker1d_background","title":"bruker1d_background","text":"<pre><code>bruker1d_background(data_path, background_path, background_factor, labels=None, xlim=None, save=False, filename=None, format=None, frame=False, normalized=False, color=None, return_fig=False)\n</code></pre> <p>Plots 1D NMR spectra from Bruker data with background removal.</p> <p>Parameters:     data_path (str): Path to the Bruker data directory.     background_path (str): Path to the Bruker background data directory.     background_factor (float): Factor to multiply the background by.</p> <p>Keyword arguments:     labels (list): List of labels for the spectra.     xlim (tuple): The limits for the x-axis.     save (bool): Whether to save the plot.     filename (str): The name of the file to save the plot.     format (str): The format to save the file in.     frame (bool): Whether to show the frame.     normalized (bool): Whether to normalize the spectra.     color (str): List of colors for the spectra.     return_fig (bool): Whether to return the figure and axis.</p> Source code in <code>spinplots/plot.py</code> <pre><code>def bruker1d_background(\n    data_path,\n    background_path,\n    background_factor,\n    labels=None,\n    xlim=None,\n    save=False,\n    filename=None,\n    format=None,\n    frame=False,\n    normalized=False,\n    color=None,\n    return_fig=False,\n):\n    \"\"\"\n    Plots 1D NMR spectra from Bruker data with background removal.\n\n    Parameters:\n        data_path (str): Path to the Bruker data directory.\n        background_path (str): Path to the Bruker background data directory.\n        background_factor (float): Factor to multiply the background by.\n\n    Keyword arguments:\n        labels (list): List of labels for the spectra.\n        xlim (tuple): The limits for the x-axis.\n        save (bool): Whether to save the plot.\n        filename (str): The name of the file to save the plot.\n        format (str): The format to save the file in.\n        frame (bool): Whether to show the frame.\n        normalized (bool): Whether to normalize the spectra.\n        color (str): List of colors for the spectra.\n        return_fig (bool): Whether to return the figure and axis.\n    \"\"\"\n\n    fig, ax = plt.subplots()\n\n    dic, data = ng.bruker.read_pdata(data_path)\n    udic = ng.bruker.guess_udic(dic, data)\n\n    nuclei = udic[0][\"label\"]\n\n    # Extract the number and nucleus symbol from the label\n    number, nucleus = (\n        \"\".join(filter(str.isdigit, nuclei)),\n        \"\".join(filter(str.isalpha, nuclei)),\n    )\n\n    uc = ng.fileiobase.uc_from_udic(udic, dim=0)\n    ppm = uc.ppm_scale()\n\n    # Normalize the spectrum\n    if normalized == \"max\" or normalized:\n        data = data / np.amax(data)\n    elif normalized == \"scans\":\n        ns = dic[\"acqus\"][\"NS\"]\n        if ns is None:\n            raise ValueError(\"Number of scans not found.\")\n        data = data / ns\n    elif normalized:\n        raise ValueError(\n            \"Invalid value for normalized. Please provide 'max' or 'scans'.\"\n        )\n\n    # Read the background data\n    dic_bg, data_bg = ng.bruker.read_pdata(background_path)\n    udic_bg = ng.bruker.guess_udic(dic_bg, data_bg)\n\n    uc_bg = ng.fileiobase.uc_from_udic(udic_bg, dim=0)\n    ppm_bg = uc_bg.ppm_scale()\n\n    if ppm.shape != ppm_bg.shape:\n        raise ValueError(\"Data and background spectra must have the same dimensions.\")\n\n    # Normalize the background\n    if normalized == \"max\" or normalized:\n        data_bg = data_bg / np.amax(data_bg)\n    elif normalized == \"scans\":\n        ns_bg = dic_bg[\"acqus\"][\"NS\"]\n        if ns_bg is None:\n            raise ValueError(\"Number of scans not found.\")\n        data_bg = data_bg / ns_bg\n    elif normalized:\n        raise ValueError(\n            \"Invalid value for normalized. Please provide 'max' or 'scans'.\"\n        )\n\n    # Remove the background\n    data = data - background_factor * data_bg\n\n    # Plot the spectrum\n    if labels is not None and color is not None:\n        ax.plot(ppm, data, label=labels, color=color)\n        ax.legend()\n    elif labels is not None:\n        ax.plot(ppm, data, label=labels)\n        ax.legend()\n    elif color is not None:\n        ax.plot(ppm, data, color=color)\n    else:\n        ax.plot(ppm, data)\n\n    # Set axis labels with LaTeX formatting and non-italicized letters\n    ax.set_xlabel(f\"$^{{{number}}}\\\\mathrm{{{nucleus}}}$ (ppm)\", fontsize=13)\n    ax.tick_params(axis=\"x\", labelsize=12)\n\n    # Remove frame\n    if not frame:\n        ax.spines[\"top\"].set_visible(False)\n        ax.spines[\"right\"].set_visible(False)\n        ax.spines[\"left\"].set_visible(False)\n        ax.set_yticklabels([])\n        ax.set_yticks([])\n    else:\n        ax.set_ylabel(\"Intensity (a.u.)\", fontsize=13)\n        ax.tick_params(axis=\"y\", labelsize=12)\n\n    # Set axis limits if provided\n    if xlim:\n        ax.set_xlim(xlim)\n\n    # Show the plot or save it\n    if save:\n        if filename:\n            full_filename = filename + \".\" + format\n        else:\n            full_filename = \"1d_nmr_spectra.\" + format\n        fig.savefig(\n            full_filename, format=format, dpi=300, bbox_inches=\"tight\", pad_inches=0.1\n        )\n        return None\n    elif return_fig:\n        return fig, ax\n    else:\n        plt.show()\n        return None\n</code></pre>"},{"location":"reference/spinplots/plot.html#spinplots.plot.bruker1d_grid","title":"bruker1d_grid","text":"<pre><code>bruker1d_grid(data_paths, labels=None, subplot_dims=(1, 1), xlim=None, save=False, filename=None, format='png', frame=False, normalized=False, color=None, return_fig=False)\n</code></pre> <p>Plots 1D NMR spectra from Bruker data in subplots.</p> <p>Parameters:     data_paths (list): List of paths to the Bruker data directories.     labels (list): List of labels for the spectra.     subplot_dims (tuple): Dimensions of the subplot grid (rows, cols).     xlim (list of tuples or tuple): The limits for the x-axis.     save (bool): Whether to save the plot.     filename (str): The name of the file to save the plot.     format (str): The format to save the file in.     frame (bool): Whether to show the frame.     normalized (bool): Whether to normalize the spectra.     color (str): List of colors for the spectra.     return_fig (bool): Whether to return the figure and axis.</p> <p>Example:     bruker1d_grid(['data/1d_data1', 'data/1d_data2'], labels=['Spectrum 1', 'Spectrum 2'], subplot_dims=(1, 2), xlim=[(0, 100), (0, 100)], save=True, filename='1d_spectra', format='png', frame=False, normalized=True, color=['red', 'blue'])</p> Source code in <code>spinplots/plot.py</code> <pre><code>def bruker1d_grid(\n    data_paths,\n    labels=None,\n    subplot_dims=(1, 1),\n    xlim=None,\n    save=False,\n    filename=None,\n    format=\"png\",\n    frame=False,\n    normalized=False,\n    color=None,\n    return_fig=False,\n):\n    \"\"\"\n    Plots 1D NMR spectra from Bruker data in subplots.\n\n    Parameters:\n        data_paths (list): List of paths to the Bruker data directories.\n        labels (list): List of labels for the spectra.\n        subplot_dims (tuple): Dimensions of the subplot grid (rows, cols).\n        xlim (list of tuples or tuple): The limits for the x-axis.\n        save (bool): Whether to save the plot.\n        filename (str): The name of the file to save the plot.\n        format (str): The format to save the file in.\n        frame (bool): Whether to show the frame.\n        normalized (bool): Whether to normalize the spectra.\n        color (str): List of colors for the spectra.\n        return_fig (bool): Whether to return the figure and axis.\n\n    Example:\n        bruker1d_grid(['data/1d_data1', 'data/1d_data2'], labels=['Spectrum 1', 'Spectrum 2'], subplot_dims=(1, 2), xlim=[(0, 100), (0, 100)], save=True, filename='1d_spectra', format='png', frame=False, normalized=True, color=['red', 'blue'])\n    \"\"\"\n    rows, cols = subplot_dims\n    fig, axes = plt.subplots(rows, cols, figsize=(5 * cols, 4 * rows))\n    axes = axes.flatten() if rows * cols &gt; 1 else [axes]\n\n    for i, data_path in enumerate(data_paths):\n        if i &gt;= len(axes):\n            break\n        ax = axes[i]\n        dic, data = ng.bruker.read_pdata(data_path)\n        udic = ng.bruker.guess_udic(dic, data)\n\n        nuclei = udic[0][\"label\"]\n        number, nucleus = (\n            \"\".join(filter(str.isdigit, nuclei)),\n            \"\".join(filter(str.isalpha, nuclei)),\n        )\n\n        uc = ng.fileiobase.uc_from_udic(udic, dim=0)\n        ppm = uc.ppm_scale()\n\n        # Check if normalized is a list or a single value\n        if isinstance(normalized, list):\n            if len(normalized) != len(data_paths):\n                raise ValueError(\n                    \"The length of the normalized list must be equal to the number of spectra.\"\n                )\n            normalized = normalized[i]\n\n        if normalized == \"max\" or normalized:\n            data = data / np.amax(data)\n        elif normalized == \"scans\":\n            ns = dic[\"acqus\"][\"NS\"]\n            if ns is None:\n                raise ValueError(\"Number of scans not found.\")\n            data = data / ns\n        elif normalized:\n            raise ValueError(\n                \"Invalid value for normalized. Please provide 'max' or 'scans'.\"\n            )\n\n        if labels and color:\n            ax.plot(ppm, data, label=labels[i], color=color[i])\n            ax.legend()\n        elif labels:\n            ax.plot(ppm, data, label=labels[i])\n            ax.legend()\n        elif color:\n            ax.plot(ppm, data, color=color[i])\n        else:\n            ax.plot(ppm, data)\n\n        ax.set_xlabel(f\"$^{{{number}}}\\\\mathrm{{{nucleus}}}$ (ppm)\", fontsize=13)\n        ax.tick_params(axis=\"x\", labelsize=12)\n\n        if not frame:\n            ax.spines[\"top\"].set_visible(False)\n            ax.spines[\"right\"].set_visible(False)\n            ax.spines[\"left\"].set_visible(False)\n            ax.set_yticklabels([])\n            ax.set_yticks([])\n        else:\n            ax.set_ylabel(\"Intensity (a.u.)\", fontsize=13)\n            ax.tick_params(axis=\"y\", labelsize=12)\n\n        if xlim and isinstance(xlim, tuple):\n            ax.set_xlim(xlim)\n        elif xlim and isinstance(xlim, list):\n            ax.set_xlim(xlim[i])\n\n    plt.tight_layout()\n\n    if save:\n        if filename:\n            full_filename = filename + \".\" + format\n        else:\n            full_filename = \"1d_nmr_spectra.\" + format\n        fig.savefig(\n            full_filename, format=format, dpi=300, bbox_inches=\"tight\", pad_inches=0.1\n        )\n        return None\n    elif return_fig:\n        return fig, axes\n    else:\n        plt.show()\n        return None\n</code></pre>"},{"location":"reference/spinplots/plot.html#spinplots.plot.bruker2d","title":"bruker2d","text":"<pre><code>bruker2d(data_path, contour_start, contour_num, contour_factor, cmap=None, colors=None, xlim=None, ylim=None, save=False, filename=None, format=None, diag=None, homo=False, return_fig=False, linewidth_contour=None, linewidth_proj=None, xaxislabel=None, yaxislabel=None, axisfont=None, axisfontsize=None, tickfont=None, tickfontsize=None, tickspacing=None)\n</code></pre> <p>Plots a 2D NMR spectrum from Bruker data.</p> <p>Parameters:     data_path (str or list): Path or list of paths to the Bruker data directories.     contour_start (float or list): Start value for the contour levels.     contour_num (int or list): Number of list of contour levels.     contour_factor (float or list): Factor or list of factors by which the contour levels increase.</p> <p>Keyword arguments:     cmap (str or list): Colormap(s) to use for the contour lines.     colors (list): Colors to use when overlaying spectra.     xlim (tuple): The limits for the x-axis.     ylim (tuple): The limits for the y-axis.     save (bool): Whether to save the plot.     filename (str): The name of the file to save the plot.     format (str): The format to save the file in.     diag (float or None): Slope of the diagonal line/None.     homo (bool): True if doing homonuclear experiment.     return_fig (bool): Whether to return the figure and axis.     linewidth_contour (float): Line width of the contour plot.     linewidth_proj (float): Line width of the projections.     xaxislabel (str): Label for the axis.     yaxislabel (str): Label for the y-axis.     axisfont (str): Font type for the axis label.     axisfontsize (int): Font size for the axis label.     tickfont (str): Font type for the tick labels.     tickfontsize (int): Font size for the tick labels.     tickspacing (int): Spacing between the tick labels.</p> <p>Example:     bruker2d('data/2d_data', 0.1, 10, 1.2, cmap='viridis', xlim=(0, 100), ylim=(0, 100), save=True, filename='2d_spectrum', format='png', diag=True)</p> Source code in <code>spinplots/plot.py</code> <pre><code>def bruker2d(\n    data_path,\n    contour_start,\n    contour_num,\n    contour_factor,\n    cmap=None,\n    colors=None,\n    xlim=None,\n    ylim=None,\n    save=False,\n    filename=None,\n    format=None,\n    diag=None,\n    homo=False,\n    return_fig=False,\n    linewidth_contour=None,\n    linewidth_proj=None,\n    xaxislabel=None,\n    yaxislabel=None,\n    axisfont=None,\n    axisfontsize=None,\n    tickfont=None,\n    tickfontsize=None,\n    tickspacing=None,\n):\n    \"\"\"\n    Plots a 2D NMR spectrum from Bruker data.\n\n    Parameters:\n        data_path (str or list): Path or list of paths to the Bruker data directories.\n        contour_start (float or list): Start value for the contour levels.\n        contour_num (int or list): Number of list of contour levels.\n        contour_factor (float or list): Factor or list of factors by which the contour levels increase.\n\n    Keyword arguments:\n        cmap (str or list): Colormap(s) to use for the contour lines.\n        colors (list): Colors to use when overlaying spectra.\n        xlim (tuple): The limits for the x-axis.\n        ylim (tuple): The limits for the y-axis.\n        save (bool): Whether to save the plot.\n        filename (str): The name of the file to save the plot.\n        format (str): The format to save the file in.\n        diag (float or None): Slope of the diagonal line/None.\n        homo (bool): True if doing homonuclear experiment.\n        return_fig (bool): Whether to return the figure and axis.\n        linewidth_contour (float): Line width of the contour plot.\n        linewidth_proj (float): Line width of the projections.\n        xaxislabel (str): Label for the axis.\n        yaxislabel (str): Label for the y-axis.\n        axisfont (str): Font type for the axis label.\n        axisfontsize (int): Font size for the axis label.\n        tickfont (str): Font type for the tick labels.\n        tickfontsize (int): Font size for the tick labels.\n        tickspacing (int): Spacing between the tick labels.\n\n    Example:\n        bruker2d('data/2d_data', 0.1, 10, 1.2, cmap='viridis', xlim=(0, 100), ylim=(0, 100), save=True, filename='2d_spectrum', format='png', diag=True)\n    \"\"\"\n\n    defaults = {\n        \"linewidth_contour\": 0.5,\n        \"linewidth_proj\": 0.8,\n        \"xaxislabel\": None,\n        \"yaxislabel\": None,\n        \"axisfont\": None,\n        \"axisfontsize\": 13,\n        \"tickfont\": None,\n        \"tickfontsize\": 12,\n        \"tickspacing\": None,\n    }\n\n    params = {k: v for k, v in locals().items() if k in defaults and v is not None}\n    defaults.update(params)\n\n    if isinstance(data_path, str):\n        data_path = [data_path]\n\n    # Create figure and axis\n    fig = plt.figure(constrained_layout=False)\n    ax = fig.subplot_mosaic(\n        \"\"\"\n    .a\n    bA\n    \"\"\",\n        gridspec_kw={\n            \"height_ratios\": [0.9, 6.0],\n            \"width_ratios\": [0.8, 6.0],\n            \"wspace\": 0.03,\n            \"hspace\": 0.04,\n        },\n    )\n\n    for i, nmr in enumerate(data_path):\n        dic, data = ng.bruker.read_pdata(nmr)\n        udic = ng.bruker.guess_udic(dic, data)\n\n        # Check if homo is set to True\n        if homo:\n            nuclei_x = udic[1][\"label\"]\n            nuclei_y = udic[1][\"label\"]\n        else:\n            nuclei_x = udic[1][\"label\"]\n            nuclei_y = udic[0][\"label\"]\n\n        # Extract the number and nucleus symbol from the label\n        number_x, nucleus_x = (\n            \"\".join(filter(str.isdigit, nuclei_x)),\n            \"\".join(filter(str.isalpha, nuclei_x)),\n        )\n        number_y, nucleus_y = (\n            \"\".join(filter(str.isdigit, nuclei_y)),\n            \"\".join(filter(str.isalpha, nuclei_y)),\n        )\n\n        uc_x = ng.fileiobase.uc_from_udic(udic, dim=1)\n        ppm_x = uc_x.ppm_scale()\n        ppm_x_limits = uc_x.ppm_limits()\n\n        uc_y = ng.fileiobase.uc_from_udic(udic, dim=0)\n        ppm_y = uc_y.ppm_scale()\n        ppm_y_limits = uc_y.ppm_limits()\n\n        # Get indices for the zoomed region if limits are specified\n        if xlim:\n            x_min_idx = np.abs(ppm_x - max(xlim)).argmin()\n            x_max_idx = np.abs(ppm_x - min(xlim)).argmin()\n            x_indices = slice(min(x_min_idx, x_max_idx), max(x_min_idx, x_max_idx))\n        else:\n            x_indices = slice(None)\n\n        if ylim:\n            y_min_idx = np.abs(ppm_y - max(ylim)).argmin()\n            y_max_idx = np.abs(ppm_y - min(ylim)).argmin()\n            y_indices = slice(min(y_min_idx, y_max_idx), max(y_min_idx, y_max_idx))\n        else:\n            y_indices = slice(None)\n\n        # Calculate projections based on the zoomed region\n        zoomed_data = data[y_indices, x_indices]\n        proj_x = np.amax(zoomed_data, axis=0)\n        proj_y = np.amax(zoomed_data, axis=1)\n\n        # Contour levels\n        contour_levels = contour_start * contour_factor ** np.arange(contour_num)\n\n        # Plot projections with the extracted color\n        # using the relevant portions of x and y ranges\n        x_proj_ppm = ppm_x[x_indices]\n        y_proj_ppm = ppm_y[y_indices]\n\n        # Plot contour lines with the provided colormap if cmap is provided\n        if cmap is not None:\n            from matplotlib.colors import LogNorm\n\n            if isinstance(cmap, str):\n                cmap = [cmap]\n                if len(cmap) &gt; 1:\n                    warnings.warn(\n                        \"Warning: Consider using colors instead of cmap\"\n                        \"when overlapping spectra.\"\n                    )\n\n            cmap_i = plt.get_cmap(cmap[i])\n            contour_plot = ax[\"A\"].contour(\n                data,\n                contour_levels,\n                extent=(\n                    ppm_x_limits[0],\n                    ppm_x_limits[1],\n                    ppm_y_limits[0],\n                    ppm_y_limits[1],\n                ),\n                cmap=cmap[i],\n                linewidths=defaults[\"linewidth_contour\"],\n                norm=LogNorm(vmin=contour_levels[0], vmax=contour_levels[-1]),\n            )\n            darkest_color = cmap_i(\n                mcolors.Normalize(vmin=contour_levels.min(), vmax=contour_levels.max())(\n                    contour_levels[0]\n                )\n            )\n            ax[\"a\"].plot(\n                x_proj_ppm,\n                proj_x,\n                linewidth=defaults[\"linewidth_proj\"],\n                color=darkest_color,\n            )\n            ax[\"a\"].axis(False)\n            ax[\"b\"].plot(\n                -proj_y,\n                y_proj_ppm,\n                linewidth=defaults[\"linewidth_proj\"],\n                color=darkest_color,\n            )\n            ax[\"b\"].axis(False)\n        elif cmap is not None and colors is not None:\n            # Error. Only one of cmap or colors can be provided.\n            raise ValueError(\"Only one of cmap or colors can be provided.\")\n        elif colors is not None and cmap is None:\n            darkest_color = colors[i]\n            contour_plot = ax[\"A\"].contour(\n                data,\n                contour_levels,\n                extent=(\n                    ppm_x_limits[0],\n                    ppm_x_limits[1],\n                    ppm_y_limits[0],\n                    ppm_y_limits[1],\n                ),\n                colors=darkest_color,\n                linewidths=defaults[\"linewidth_contour\"],\n            )\n            ax[\"a\"].plot(\n                x_proj_ppm,\n                proj_x,\n                linewidth=defaults[\"linewidth_proj\"],\n                color=darkest_color,\n            )\n            ax[\"a\"].axis(False)\n            ax[\"b\"].plot(\n                -proj_y,\n                y_proj_ppm,\n                linewidth=defaults[\"linewidth_proj\"],\n                color=darkest_color,\n            )\n            ax[\"b\"].axis(False)\n        else:\n            darkest_color = \"black\"\n            contour_plot = ax[\"A\"].contour(\n                data,\n                contour_levels,\n                extent=(\n                    ppm_x_limits[0],\n                    ppm_x_limits[1],\n                    ppm_y_limits[0],\n                    ppm_y_limits[1],\n                ),\n                colors=\"black\",\n                linewidths=defaults[\"linewidth_contour\"],\n            )\n            ax[\"a\"].plot(\n                x_proj_ppm,\n                proj_x,\n                linewidth=defaults[\"linewidth_proj\"],\n                color=darkest_color,\n            )\n            ax[\"a\"].axis(False)\n            ax[\"b\"].plot(\n                -proj_y,\n                y_proj_ppm,\n                linewidth=defaults[\"linewidth_proj\"],\n                color=darkest_color,\n            )\n            ax[\"b\"].axis(False)\n\n        if xaxislabel:\n            defaults[\"xaxislabel\"] = xaxislabel\n        else:\n            defaults[\"xaxislabel\"] = f\"$^{{{number_x}}}\\\\mathrm{{{nucleus_x}}}$ (ppm)\"\n        if yaxislabel:\n            defaults[\"yaxislabel\"] = yaxislabel\n        else:\n            defaults[\"yaxislabel\"] = f\"$^{{{number_y}}}\\\\mathrm{{{nucleus_y}}}$ (ppm)\"\n\n        ax[\"A\"].set_xlabel(\n            defaults[\"xaxislabel\"],\n            fontsize=defaults[\"axisfontsize\"],\n            fontname=defaults[\"axisfont\"] if defaults[\"axisfont\"] else None,\n        )\n        ax[\"A\"].set_ylabel(\n            defaults[\"yaxislabel\"],\n            fontsize=defaults[\"axisfontsize\"],\n            fontname=defaults[\"axisfont\"] if defaults[\"axisfont\"] else None,\n        )\n        ax[\"A\"].yaxis.set_label_position(\"right\")\n        ax[\"A\"].yaxis.tick_right()\n        ax[\"A\"].tick_params(\n            axis=\"x\",\n            labelsize=defaults[\"tickfontsize\"],\n            labelfontfamily=defaults[\"tickfont\"] if defaults[\"tickfont\"] else None,\n        )\n        ax[\"A\"].tick_params(\n            axis=\"y\",\n            labelsize=defaults[\"tickfontsize\"],\n            labelfontfamily=defaults[\"tickfont\"] if defaults[\"tickfont\"] else None,\n        )\n\n        # Plot diagonal line if diag is provided\n        if diag is not None:\n            x_diag = np.linspace(ppm_x_limits[0], ppm_x_limits[1], 100)\n            y_diag = diag * x_diag\n            ax[\"A\"].plot(x_diag, y_diag, linestyle=\"--\", color=\"gray\")\n\n        # Set axis limits if provided\n        if xlim:\n            ax[\"A\"].set_xlim(xlim)\n            ax[\"a\"].set_xlim(xlim)\n        if ylim:\n            ax[\"A\"].set_ylim(ylim)\n            ax[\"b\"].set_ylim(ylim)\n\n    # Show the plot or save it\n    if save:\n        if filename:\n            full_filename = filename + \".\" + format\n        else:\n            full_filename = \"2d_nmr_spectrum.\" + format\n        plt.savefig(\n            full_filename, format=format, dpi=300, bbox_inches=\"tight\", pad_inches=0.1\n        )\n\n    if return_fig:\n        return ax\n    else:\n        plt.show()\n        return None\n</code></pre>"},{"location":"reference/spinplots/plot.html#spinplots.plot.df2d","title":"df2d","text":"<pre><code>df2d(path, contour_start, contour_num, contour_factor, cmap=None, xlim=None, ylim=None, save=False, filename=None, format=None, return_fig=False)\n</code></pre> <p>Plot 2D NMR data from a CSV file or a DataFrame.</p> <p>Parameters: path (str): Path to the CSV file. contour_start (float): Contour start value. contour_num (int): Number of contour levels. contour_factor (float): Contour factor.</p> <p>Keyword arguments:     cmap (str): The colormap to use for the contour lines.     xlim (tuple): The limits for the x-axis.     ylim (tuple): The limits for the y-axis.     save (bool): Whether to save the plot.     filename (str): The name of the file to save the plot.     format (str): The format to save the file in.     return_fig (bool): Whether to return the figure and axis.</p> <p>Example: df2d('nmr_data.csv', contour_start=4e3, contour_num=10, contour_factor=1.2, cmap='viridis', xlim=(0, 100), ylim=(0, 100), save=True, filename='2d_spectrum', format='png')</p> Source code in <code>spinplots/plot.py</code> <pre><code>def df2d(\n    path,\n    contour_start,\n    contour_num,\n    contour_factor,\n    cmap=None,\n    xlim=None,\n    ylim=None,\n    save=False,\n    filename=None,\n    format=None,\n    return_fig=False,\n):\n    \"\"\"\n    Plot 2D NMR data from a CSV file or a DataFrame.\n\n    Parameters:\n    path (str): Path to the CSV file.\n    contour_start (float): Contour start value.\n    contour_num (int): Number of contour levels.\n    contour_factor (float): Contour factor.\n\n    Keyword arguments:\n        cmap (str): The colormap to use for the contour lines.\n        xlim (tuple): The limits for the x-axis.\n        ylim (tuple): The limits for the y-axis.\n        save (bool): Whether to save the plot.\n        filename (str): The name of the file to save the plot.\n        format (str): The format to save the file in.\n        return_fig (bool): Whether to return the figure and axis.\n\n    Example:\n    df2d('nmr_data.csv', contour_start=4e3, contour_num=10, contour_factor=1.2, cmap='viridis', xlim=(0, 100), ylim=(0, 100), save=True, filename='2d_spectrum', format='png')\n    \"\"\"\n\n    # Check if path to CSV or DataFrame\n    df_nmr = path if isinstance(path, pd.DataFrame) else pd.read_csv(path)\n\n    cols = df_nmr.columns\n    f1_nuclei, f1_units = cols[0].split()\n    number_x, nucleus_x = (\n        \"\".join(filter(str.isdigit, f1_nuclei)),\n        \"\".join(filter(str.isalpha, f1_nuclei)),\n    )\n    f2_nuclei, f2_units = cols[1].split()\n    number_y, nucleus_y = (\n        \"\".join(filter(str.isdigit, f2_nuclei)),\n        \"\".join(filter(str.isalpha, f2_nuclei)),\n    )\n    data_grid = df_nmr.pivot_table(index=cols[0], columns=cols[1], values=\"intensity\")\n    proj_f1, proj_f2 = calculate_projections(df_nmr, export=False)\n\n    f1 = data_grid.index.to_numpy()\n    f2 = data_grid.columns.to_numpy()\n    x, y = np.meshgrid(f2, f1)\n    z = data_grid.to_numpy()\n\n    contour_levels = contour_start * contour_factor ** np.arange(contour_num)\n\n    ax = plt.figure(constrained_layout=False).subplot_mosaic(\n        \"\"\"\n    .a\n    bA\n    \"\"\",\n        gridspec_kw={\n            \"height_ratios\": [0.9, 6.0],\n            \"width_ratios\": [0.8, 6.0],\n            \"wspace\": 0.03,\n            \"hspace\": 0.04,\n        },\n    )\n\n    if cmap is not None:\n        ax[\"A\"].contourf(\n            x,\n            y,\n            z,\n            contour_levels,\n            cmap=cmap,\n            norm=LogNorm(vmin=contour_levels[0], vmax=contour_levels[-1]),\n        )\n    else:\n        ax[\"A\"].contourf(\n            x,\n            y,\n            z,\n            contour_levels,\n            cmap=\"Greys\",\n            norm=LogNorm(vmin=contour_levels[0], vmax=contour_levels[-1]),\n        )\n\n    # Plot projections with the extracted color\n    ax[\"a\"].plot(\n        proj_f2[f\"{f2_nuclei} {f2_units}\"], proj_f2[\"F2 projection\"], color=\"black\"\n    )\n    ax[\"a\"].axis(False)\n    ax[\"b\"].plot(\n        -proj_f1[\"F1 projection\"], proj_f1[f\"{f1_nuclei} {f1_units}\"], color=\"black\"\n    )\n    ax[\"b\"].axis(False)\n\n    # Set axis labels with LaTeX formatting and non-italicized letters and position\n    ax[\"A\"].set_xlabel(f\"$^{{{number_y}}}\\\\mathrm{{{nucleus_y}}}$ (ppm)\", fontsize=13)\n    ax[\"A\"].set_ylabel(f\"$^{{{number_x}}}\\\\mathrm{{{nucleus_x}}}$ (ppm)\", fontsize=13)\n    ax[\"A\"].yaxis.set_label_position(\"right\")\n    ax[\"A\"].yaxis.tick_right()\n    ax[\"A\"].tick_params(axis=\"x\", labelsize=12)\n    ax[\"A\"].tick_params(axis=\"y\", labelsize=12)\n\n    # Set axis limits if provided\n    if xlim:\n        ax[\"A\"].set_xlim(xlim)\n        ax[\"a\"].set_xlim(xlim)\n    if ylim:\n        ax[\"A\"].set_ylim(ylim)\n        ax[\"b\"].set_ylim(ylim)\n\n    if save:\n        if filename:\n            full_filename = filename + \".\" + format\n        else:\n            full_filename = \"2d_nmr_spectrum.\" + format\n        plt.savefig(\n            full_filename, format=format, dpi=300, bbox_inches=\"tight\", pad_inches=0.1\n        )\n        return None\n    elif return_fig:\n        return ax\n    else:\n        plt.show()\n        return None\n</code></pre>"},{"location":"reference/spinplots/utils.html","title":"utils","text":""},{"location":"reference/spinplots/utils.html#spinplots.utils.calculate_projections","title":"calculate_projections","text":"<pre><code>calculate_projections(data, export=False, filename=None)\n</code></pre> <p>Calculate F1 and F2 projections from a DataFrame or a CSV file.</p> <p>Parameters: data (pd.DataFrame or str): DataFrame or path to a CSV file. export (bool): If True, export the projections to a CSV file. Default is False. filename (str): Name of the exported CSV file. Default is 'projections_f1.csv' and 'projections_f2.csv'.</p> <p>Returns: pd.DataFrame: DataFrame containing the F1 and F2 projections.</p> Source code in <code>spinplots/utils.py</code> <pre><code>def calculate_projections(data, export=False, filename=None):\n    \"\"\"\n    Calculate F1 and F2 projections from a DataFrame or a CSV file.\n\n    Parameters:\n    data (pd.DataFrame or str): DataFrame or path to a CSV file.\n    export (bool): If True, export the projections to a CSV file. Default is False.\n    filename (str): Name of the exported CSV file. Default is 'projections_f1.csv'\n    and 'projections_f2.csv'.\n\n    Returns:\n    pd.DataFrame: DataFrame containing the F1 and F2 projections.\n    \"\"\"\n    if isinstance(data, str):\n        df_nmr = pd.read_csv(data)\n    elif isinstance(data, pd.DataFrame):\n        df_nmr = data\n    else:\n        raise ValueError(\"Data must be a DataFrame or a path to a CSV file.\")\n\n    cols = df_nmr.columns\n    f1_nuclei, f1_units = cols[0].split()\n    f2_nuclei, f2_units = cols[1].split()\n    data = (\n        df_nmr[\"intensity\"]\n        .to_numpy()\n        .reshape(len(df_nmr[cols[0]].unique()), len(df_nmr[cols[1]].unique()))\n    )\n\n    f1_proj = np.max(data, axis=1)\n    f2_proj = np.max(data, axis=0)\n\n    # Define df_pos that might have different sizes\n    df_f1 = pd.DataFrame(\n        {\n            f\"{f1_nuclei} {f1_units}\": df_nmr[cols[0]].unique(),\n            \"F1 projection\": f1_proj,\n        }\n    )\n\n    df_f2 = pd.DataFrame(\n        {\n            f\"{f2_nuclei} {f2_units}\": df_nmr[cols[1]].unique(),\n            \"F2 projection\": f2_proj,\n        }\n    )\n\n    if export:\n        if filename is None:\n            filename = \"projections\"\n        df_f1.to_csv(f\"{filename}_f1.csv\", index=False)\n        df_f2.to_csv(f\"{filename}_f2.csv\", index=False)\n    elif not export:\n        return df_f1, df_f2\n\n    return None, None\n</code></pre>"},{"location":"reference/spinplots/utils.html#spinplots.utils.nmr_df","title":"nmr_df","text":"<pre><code>nmr_df(data_path, hz=False, export=False, filename=None)\n</code></pre> <p>Reads Bruker's NMR 1D and 2D data and converts it into a pandas DataFrame.</p> <p>Parameters: data_path (str): Path to the NMR data. hz (bool): If True, use Hz scale instead of ppm scale. Default is False. export (bool): If True, export the DataFrame to a CSV file. Default is False. filename (str): Name of the exported CSV file. Default is 'nmr_data.csv'.</p> <p>Returns: pd.DataFrame: DataFrame containing the NMR data.</p> Source code in <code>spinplots/utils.py</code> <pre><code>def nmr_df(data_path, hz=False, export=False, filename=None):\n    \"\"\"\n    Reads Bruker's NMR 1D and 2D data and converts it into a pandas DataFrame.\n\n    Parameters:\n    data_path (str): Path to the NMR data.\n    hz (bool): If True, use Hz scale instead of ppm scale. Default is False.\n    export (bool): If True, export the DataFrame to a CSV file. Default is False.\n    filename (str): Name of the exported CSV file. Default is\n    'nmr_data.csv'.\n\n    Returns:\n    pd.DataFrame: DataFrame containing the NMR data.\n    \"\"\"\n    dic, data = ng.bruker.read_pdata(data_path)\n    udic = ng.bruker.guess_udic(dic, data)\n    ndim = udic[\"ndim\"]\n\n    if ndim == 1:\n        nuclei = udic[0][\"label\"]\n        uc = ng.fileiobase.uc_from_udic(udic, dim=0)\n        ppm = uc.ppm_scale()\n        hz = uc.hz_scale()\n        ndata = data / np.max(data)\n        df_nmr = pd.DataFrame(\n            {\n                \"hz\": hz,\n                \"ppm\": ppm,\n                \"intensity\": data,\n                \"norm_intensity\": ndata,\n                \"nuclei\": nuclei,\n            }\n        )\n        df_nmr.attrs[\"nmr_dim\"] = ndim\n    elif ndim == 2:\n        nuclei = [udic[0][\"label\"], udic[1][\"label\"]]\n        uc_f1 = ng.fileiobase.uc_from_udic(udic, dim=0)\n        uc_f2 = ng.fileiobase.uc_from_udic(udic, dim=1)\n        ppm_f1 = uc_f1.ppm_scale()\n        ppm_f2 = uc_f2.ppm_scale()\n        hz_f1 = uc_f1.hz_scale()\n        hz_f2 = uc_f2.hz_scale()\n\n        if hz:\n            F1_hz, F2_hz = np.meshgrid(hz_f1, hz_f2, indexing=\"ij\")\n            df_nmr = pd.DataFrame(\n                {\n                    f\"{nuclei[0]} hz\": F1_hz.flatten(),\n                    f\"{nuclei[1]} hz\": F2_hz.flatten(),\n                    \"intensity\": data.flatten(),\n                }\n            )\n\n        else:\n            F1_ppm, F2_ppm = np.meshgrid(ppm_f1, ppm_f2, indexing=\"ij\")\n            df_nmr = pd.DataFrame(\n                {\n                    f\"{nuclei[0]} ppm\": F1_ppm.flatten(),\n                    f\"{nuclei[1]} ppm\": F2_ppm.flatten(),\n                    \"intensity\": data.flatten(),\n                }\n            )\n\n        df_nmr.attrs[\"nmr_dim\"] = ndim\n    else:\n        raise ValueError(\"Only 1D and 2D NMR data are supported.\")\n\n    if export:\n        if filename is None:\n            filename = \"nmr_data.csv\"\n        df_nmr.to_csv(filename, index=False)\n        return None\n    elif not export:\n        return df_nmr\n    return None\n</code></pre>"},{"location":"user_guide/easy_plots.html","title":"Easy Plots","text":"<p>The current version of <code>SpinPlots</code> only works with processed Bruker data. If you\u2019re dealing with unprocessed data or using data from a different brand, we recommend using NMRglue instead. Also, if you want more control over the looks of your plot, <code>SpinPlots</code> might feel a bit limited since it mostly sticks to the default matplotlib style for now.</p> <p>For this tutorial a series of <sup>13</sup>C,<sup>15</sup>N-labelled Tyrosine and <sup>13</sup>C,<sup>15</sup>N labelled Glycine spectra are used to show the implementation of <code>SpinPlots</code>.</p> <pre><code>from spinplots.plot import bruker1d, bruker1d_grid, bruker2d\n</code></pre> <p>Here is how to load and plot a simple 1D spectrum of Tyrosine acquired at 9.4T using a MAS rate of 10kHz</p> <pre><code>bruker1d(['../../data/1D/tyrosine/pdata/1'], xlim=(200, -10))\n</code></pre> <p><code>SpinPlots</code> uses Matplotlib's standard style by default. If you want to customize the appearance of your spectra, you can use the option <code>return_fig=True</code>. This allows you to return the figure object and modify it as needed before displaying or saving it.</p> <p>This section shows how plotting can be implemented using the <code>return_fig=True</code>. </p> <p>The <code>bruker1d</code> function has a bunch of useful features beyond just making a simple plot. Some of the key ones include:</p> <ul> <li>Plotting several plots together</li> <li>Plot with/without frame</li> <li>Labelling of spectra</li> <li>Normalization of data</li> <li>Select colors for each spectrum using matplotlib's colors</li> <li>Saving the plot directly to a file</li> </ul> <p>The following examples includes all options currently available in the <code>bruker1d</code> function.</p> <pre><code>path = '../../data/1D/'\nbruker1d([path + 'tyrosine/pdata/1'],\n              labels=['Tyrosine'],      # Set the labels for the spectra \n              color=['black'],          # Set the colors for the spectra\n              xlim=(200, 0),            # Set the x-axis limits\n              alpha=1,                  # Set the transparency of the lines (1 for no transparency, 0 for transparent)\n              linewidth=2,              # Set the line width\n              linestyle='-',            # Set the line style (styles, e.g. '--', ':', '-.', etc.)\n              axisfont='Arial',         # Set the font style of the axis labels\n              axisfontsize=12,          # Set the font size of the axis labels\n              tickfont='Arial',         # Set the font style of the tick labels\n              tickfontsize=10,          # Set the font size of the tick labels\n              tickspacing=20,           # Set the spacing between the ticks on X-axis\n              frame=True,               # Set True or False to add or remove frame\n              save=False,               # Set True or False to save the figure\n              filename='../../data/1D/tyrosine_13C',          # Set the path and filename for saving the figure\n              format='svg')             # Set the format of the saved figure (e.g. 'png', 'pdf', 'svg', etc.)\n</code></pre> <p><code>bruker1d</code> function sets the Y-axis and X-axis labels automatically based on the data loaded.</p> <p>The Y-axis and X-axis labels can be edited with the <code>yaxislabel</code> and <code>xaxislabel</code> options, as follows :</p> <pre><code>path = '../../data/1D/'\nbruker1d([path + 'tyrosine/pdata/1'],\n              labels=['Tyrosine'],      \n              color=['black'],          \n              xlim=(200, 0),            \n              xaxislabel='my label 1',      # Set the label for the x-axis\n              yaxislabel='my label 2',      # Set the label for the y-axis\n              frame=True,               \n              save=False,                \n              filename='../../data/1D/tyrosine_13C',\n              format='svg')\n</code></pre> <p>For multiple spectra, <code>bruker1d</code> function supports normalization of data and plot stacking. For this example two <sup>13</sup>C NMR datasets of Tyrosine and Glycine are used with different number of scans.</p> <pre><code>path = '../../data/1D/'\nbruker1d([path + 'glycine/pdata/1', path + 'tyrosine/pdata/1'],\n              labels=['Glycine', 'Tyrosine'],\n              color=['orange', 'blue'],\n              xlim=(200, 0),\n              alpha=1,\n              linewidth=1,\n              linestyle='-',\n              axisfont='Arial',\n              axisfontsize=12,\n              tickfont='Arial',\n              tickfontsize=10,\n              tickspacing=20,\n              frame=True,\n              save=True,\n              filename='../../data/1D/overlapped',\n              format='svg')\n</code></pre> <p>The spectrum can be normalized using the <code>normalize</code> option, as follows :</p> <pre><code>path = '../../data/1D/'\nbruker1d([path + 'glycine/pdata/1', path + 'tyrosine/pdata/1'],\n              labels=['Glycine', 'Tyrosine'],\n              color=['orange', 'blue'],\n              xlim=(200, 0),\n              alpha=1,\n              linewidth=1,\n              linestyle='-',\n              axisfont='Arial',\n              axisfontsize=12,\n              tickfont='Arial',\n              tickfontsize=10,\n              tickspacing=20,\n              normalized=True,      # Set to True to normalize the spectra\n              frame=True,\n              save=False,\n              filename='../../data/1D/overlapped',\n              format='svg')\n</code></pre> <p>The spectra can be normalized either by the highest intensity using <code>normalized='max'</code> or by the number of scans using <code>normalized='scans'</code>.</p> <p>Multiple spectra can be plotted using the <code>stacked</code> option, as follows :</p> <pre><code>path = '../../data/1D/'\nbruker1d([path + 'glycine/pdata/1', path + 'tyrosine/pdata/1'],\n              labels=['Glycine', 'Tyrosine'],\n              color=['orange', 'blue'],\n              xlim=(200, 0),\n              alpha=1,\n              linewidth=1,\n              linestyle='-',\n              axisfont='Arial',\n              axisfontsize=12,\n              tickfont='Arial',\n              tickfontsize=10,\n              tickspacing=20,\n              normalized=True,\n              stacked=True,         # Set to True to stack the spectra     \n              frame=True,\n              save=False,\n              filename='../../data/1D/stacked',\n              format='svg')\n</code></pre> <p>or with more plots</p> <pre><code>path = '../../data/1D/'\nbruker1d([path + 'glycine/pdata/1', path + 'tyrosine/pdata/1', path + 'alanine/pdata/1', path + 'arginine/pdata/1'],\n              labels=['Glycine', 'Tyrosine', 'Alanine', 'Arginine'],\n              color=['#03045e', '#023e8a', '#0077b6', '#0096c7'],       # Hex color codes is also supported\n              xlim=(200, 0),\n              alpha=1,\n              linewidth=1,\n              linestyle='-',\n              axisfont='Arial',\n              axisfontsize=12,\n              tickfont='Arial',\n              tickfontsize=10,\n              tickspacing=20,\n              normalized=True,\n              stacked=True,         # Set to True to stack the spectra     \n              frame=True,\n              save=False,\n              filename='../../data/1D/stacked',\n              format='svg')\n</code></pre> <p>The <code>bruker1d_grid</code> function works similarly to <code>bruker1d</code>, but instead of overlapping the spectra, it allows the presentation of multiple spectra in a grid style (subplots), and can be used as follows :</p> <pre><code>path = '../../data/1D/'\nbruker1d_grid([path + 'glycine/pdata/1', path + 'tyrosine/pdata/1'],\n              labels=['Glycine', 'Tyrosine'],\n              color=['orange', 'blue'],\n              xlim=(200, 0),\n              subplot_dims=(1, 2),        # Set the number of subplots in the grid\n              normalized=True,\n              frame=True,\n              save=False,\n              filename='../../data/1D/grid',\n              format='svg')\n</code></pre> <p>More complex grid spaces can be created, as follows :</p> <pre><code>path = '../../data/1D/'\nbruker1d_grid([path + 'glycine/pdata/1', path + 'tyrosine/pdata/1', path + 'alanine/pdata/1', path + 'arginine/pdata/1'],\n              labels=['Glycine', 'Tyrosine', 'Alanine', 'Arginine'],\n              color=['#03045e', '#023e8a', '#0077b6', '#0096c7'],       # Hex color codes is also supported\n              xlim=(200, 0),\n              subplot_dims=(2, 2),        # Set the number of subplots in the grid\n              normalized=True,\n              frame=True,\n              save=False,\n              filename='../../data/1D/grid',\n              format='svg')\n</code></pre> <p>Lastly, the <code>bruker2d</code> function makes it super easy to plot 2D NMR spectra. You just need to provide a bit more info to customize the plot. Here\u2019s what you can specify:</p> <ul> <li><code>countour_start</code>: the minimum value for the contour plot</li> <li><code>countour_num</code>: how many contour levels you want</li> <li><code>countour_factor</code>: the factor between each contour level</li> <li><code>cmap</code>: the matplotlib colormap for countour (default is 'black')</li> <li><code>colors</code>: can be used instead of <code>cmap</code> with values such as <code>blue</code>, <code>red</code>, etc.</li> <li><code>xlim</code>: limits for the x-axis, i.e. direct dimension (F2)</li> <li><code>ylim</code>: limits for the y-axis, i.e. indirect dimension (F1)</li> <li><code>save</code>: whether you want to save the plot</li> <li><code>filename</code>: the name to save the plot as</li> <li><code>format</code>: the file format to save it</li> </ul> <p>The following example includes all options currently available in the <code>bruker2d</code> function.</p> <p>A simple heteronuclear {<sup>1</sup>H}-<sup>13</sup>C 2D acquired at 9.4T using a MAS rate of 10kHz can be plotted, as follows :</p> <pre><code>bruker2d('../../data/2D/43/pdata/1',\n        contour_start=4e10,     # Set the starting value for the contour lines\n        contour_num=12,         # Set the number of contour lines\n        contour_factor=1.5,     # Set the factor for the contour lines\n        cmap='viridis',         # Set the colormap for the contour plot. Available colormaps: https://matplotlib.org/stable/users/explain/colors/colormaps.html\n        xlim=(180, 30),         # Set the x-axis limits\n        ylim=(14, -2),          # Set the y-axis limits\n        linewidth_contour=1,    # Set the line width for the contour lines\n        linewidth_proj=1.5,     # Set the line width for the projection lines\n        axisfont='Arial',       # Set the font style of the axis labels\n        axisfontsize=12,        # Set the font size of the axis labels\n        tickfont='Arial',       # Set the font style of the tick labels\n        tickfontsize=10,        # Set the font size of the tick labels\n        tickspacing=20,         # Set the spacing between the ticks on X-axis\n        save=False,             # Set True or False to save the figure\n        filename='../../data/2D/2d_hetero',     # Set the path and filename for saving the figure\n        format='png',)          # Set the format of the saved figure (e.g. 'png', 'pdf', 'svg', etc.)\n</code></pre> <p>Some NMR spectra, like double-quantum (DQ) experiments, are often visualized with a diagonal line representing <code>y=2x</code>. You can add this diagonal line for any line of the form <code>y=nx</code> using the keyword <code>diag=n</code>, where <code>n</code> sets the desired quantum order. The following example shows a <sup>13</sup>C-<sup>13</sup>C DQ-SQ experiment. The option <code>homo=True</code> is only needed if the y-axis label isn\u2019t displaying correctly, such as when the DQ-SQ is acquired through CPMAS.</p> <p>Similarly, a simple homonuclear <sup>13</sup>C-<sup>13</sup>C 2D can be plotted, as follows :</p> <pre><code>bruker2d('../../data/2D/16/pdata/1',\n        contour_start=1e7,\n        contour_num=25,\n        contour_factor=1.5,\n        cmap='viridis',\n        xlim=(200, 30),\n        ylim=(400, 60),\n        linewidth_contour=1,\n        linewidth_proj=1.5,\n        axisfont='Arial',\n        axisfontsize=12,\n        tickfont='Arial',\n        tickfontsize=10,\n        tickspacing=20,\n\n        homo=True,              # Set to true if spectra is a homonuclear correlation\n        diag=2,                 # Set the diagonal live declive\n\n        save=False,\n        filename='../../data/2D/2d_homo',\n        format='png',)\n</code></pre> <p><code>bruker2d</code> function sets the Y-axis and X-axis labels automatically based on the data loaded, but you can edit them with the <code>yaxislabel</code> and <code>xaxislabel</code> options, as follows :</p> <pre><code>bruker2d('../../data/2D/16/pdata/1',\n        contour_start=1e7,\n        contour_num=25,\n        contour_factor=1.5,\n        cmap='viridis',\n        xlim=(200, 30),\n        ylim=(400, 60),\n        linewidth_contour=1,\n        linewidth_proj=1.5,\n        axisfont='Arial',\n        axisfontsize=12,\n        tickfont='Arial',\n        tickfontsize=10,\n        tickspacing=20,\n        homo=True,\n        diag=2,\n\n        xaxislabel='SQ $^{13}$C (ppm)',         # Set the label for the X-axis\n        yaxislabel='DQ $^{13}$C (ppm)',         # Set the label for the Y-axis\n\n        save=False,\n        filename='../../data/2D/2d_homo',\n        format='png',)\n</code></pre>"},{"location":"user_guide/easy_plots.html#plot-1d-spectra","title":"Plot 1D spectra","text":""},{"location":"user_guide/easy_plots.html#costumization-of-1d-spectra","title":"Costumization of 1D spectra","text":""},{"location":"user_guide/easy_plots.html#normalization","title":"Normalization","text":""},{"location":"user_guide/easy_plots.html#stacking","title":"Stacking","text":""},{"location":"user_guide/easy_plots.html#grid","title":"Grid","text":""},{"location":"user_guide/easy_plots.html#plot-2d-spectra","title":"Plot 2D spectra","text":""},{"location":"user_guide/easy_plots.html#heteronuclear-correlation","title":"Heteronuclear correlation","text":""},{"location":"user_guide/easy_plots.html#homonuclear-correlation","title":"Homonuclear correlation","text":""},{"location":"user_guide/read_export.html","title":"Costumize and Export","text":"<p>The functions in the previous tutorial make plotting pretty automatic, using matplotlib's standard style. But sometimes, you might just want to read the data without immediately plotting it\u2014maybe to style it your own way or to convert it into a different format.</p> <pre><code>from spinplots.plot import bruker1d\nfrom spinplots.utils import nmr_df\nimport matplotlib.pyplot as plt\n</code></pre> <p>In the previous tutorial, we used <code>bruker1d(['../../data/1D/glycine/pdata/1'], xlim=(250, -20))</code> to create a simple <sup>13</sup>C NMR plot. By adding the option <code>return_fig=True</code>, you can return the figure object, which allows you to further customize the appearance of the spectrum as you like.</p> <pre><code>fig, ax = bruker1d(['../../data/1D/glycine/pdata/1'], xlim=(250, -20), return_fig=True)\nax.set_title('Customized plot')\nax.set_xlabel('13-Carbon NMR in ppm') \nax.lines[0].set_color('purple')\nax.lines[0].set_linewidth(2)\nax.lines[0].set_linestyle('-.')\nfig.savefig('../../data/1D/customized_plot.png')\n</code></pre> <p>A different option is to use the <code>nmr_df</code> function from <code>spinplots.utils</code> to get a Pandas DataFrame. This way, you can manipulate the data however you like before plotting.</p> <pre><code>df = nmr_df('../../data/1D/glycine/pdata/1')\nprint(df)\n</code></pre> <pre>\n<code>                 hz         ppm   intensity  norm_intensity nuclei\n0      62320.002580  619.310059  36928800.0        0.004269    13C\n1      62318.476701  619.294895  40210336.0        0.004648    13C\n2      62316.950822  619.279732  39049024.0        0.004514    13C\n3      62315.424943  619.264568  33449568.0        0.003867    13C\n4      62313.899064  619.249404  23894656.0        0.002762    13C\n...             ...         ...         ...             ...    ...\n65531 -37672.368025 -374.372200 -20542656.0       -0.002375    13C\n65532 -37673.893904 -374.387363  -8086976.0       -0.000935    13C\n65533 -37675.419783 -374.402527   5093344.0        0.000589    13C\n65534 -37676.945662 -374.417690  17696256.0        0.002046    13C\n65535 -37678.471541 -374.432854  28418208.0        0.003285    13C\n\n[65536 rows x 5 columns]\n</code>\n</pre> <pre><code>plt.plot(df['ppm'], df['intensity'], color='green')\nplt.xlim(250, -20)\nplt.xlabel('$^{31}$C (ppm)')\nplt.ylabel('Intensity (a.u.)')\nplt.show()\n</code></pre> <p>Pandas DataFrames can be easily exported to other formats such as <code>.csv</code>. You can do this directly in your code with <code>df.to_csv('exported_data.csv')</code>, or use the <code>bruker2csv</code> function from the terminal for a quick export.</p> <pre><code>bruker2csv ../../data/1D/glycine/pdata/1 ../../data/1D/exported_data.csv\n</code></pre>"},{"location":"user_guide/read_export.html#read-and-export-data","title":"Read and Export data","text":""},{"location":"user_guide/read_export.html#customize-spinplots","title":"Customize spinplots","text":""},{"location":"user_guide/read_export.html#export-data-to-pandas-and-csv","title":"Export data to Pandas and CSV","text":""},{"location":"user_guide/read_export.html#convert-data-in-the-terminal","title":"Convert data in the terminal","text":""}]}